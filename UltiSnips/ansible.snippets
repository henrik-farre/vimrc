# Generated by https://github.com/pearofducks/ansible-vim/blob/master/UltiSnips/generate.py
priority -50

snippet ldap_attr "Add or remove LDAP attribute values." b
ldap_attr:
	dn: ${1:# The DN of the entry to modify.}
	name: ${2:# The name of the attribute to modify.}
	values: ${3:# The value(s) to add or remove. This can be a string or a list of strings. The complex argument format is required in order to pass a list of strings (see examples).}

	server_uri: ${4:ldapi:///}
	start_tls: ${5:yes|#no}
	bind_dn: ${6:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.}
	state: ${7:#present|absent|exact}
	bind_pw: ${8:# The password to use with I(bind_dn).}

endsnippet

snippet nsupdate "Manage DNS records." b
nsupdate:
	zone: ${1:# DNS record will be modified on this C(zone).}
	server: ${2:# Apply DNS modification on this server.}
	record: ${3:# Sets the DNS record to modify.}

	key_algorithm: ${4:HMAC-MD5.SIG-ALG.REG.INT|#hmac-md5|hmac-sha1|hmac-sha224|hmac-sha256|hamc-sha384|hmac-sha512}
	key_name: ${5:# Use TSIG key name to authenticate against DNS C(server)}
	value: ${6:# Sets the record value.}
	state: ${7:#present|absent}
	ttl: ${8:3600}
	type: ${9:A}
	key_secret: ${10:# Use TSIG key secret, associated with C(key_name), to authenticate against C(server)}

endsnippet

snippet ldap_entry "Add or remove LDAP entries." b
ldap_entry:
	dn: ${1:# The DN of the entry to add or remove.}

	objectClass: ${2:# If I(state=present), value or list of values to use when creating the entry. It can either be a string or an actual list of strings.}
	start_tls: ${3:yes|#no}
	bind_dn: ${4:# A DN to bind with. If this is omitted, we'll try a SASL bind with the EXTERNAL mechanism. If this is blank, we'll use an anonymous bind.}
	server_uri: ${5:ldapi:///}
	state: ${6:#present|absent}
	params: ${7:# List of options which allows to overwrite any of the task or the I(attributes) options. To remove an option, set the value of the option to C(null).}
	bind_pw: ${8:# The password to use with I(bind_dn).}
	attributes: ${9:# If I(state=present), attributes necessary to create an entry. Existing entries are never modified. To assert specific attribute values on an existing entry, use M(ldap_attr) module instead.}

endsnippet

snippet nmcli "Manage Networking" b
nmcli:
	conn_name: ${1:# Where conn_name will be the name used to call the connection. when not provided a default name is generated: <type>[-<ifname>][-<num>]}
	state: ${2:present|absent}

	ingress: ${3:# This is only used with VLAN - VLAN ingress priority mapping}
	slavepriority: ${4:32}
	path_cost: ${5:100}
	vlandev: ${6:# This is only used with VLAN - parent device this VLAN is on, can use ifname}
	forwarddelay: ${7:15}
	primary: ${8:# This is only used with bond and is the primary interface name (for "active-backup" mode), this is the usually the 'ifname'}
	hairpin: ${9:yes}
	egress: ${10:# This is only used with VLAN - VLAN egress priority mapping}
	ageingtime: ${11:300}
	dns4: ${12:# A list of upto 3 dns servers, ipv4 format e.g. To add two IPv4 DNS server addresses: ["192.0.2.53", "198.51.100.53"]}
	arp_ip_target: ${13:# This is only used with bond - ARP IP target}
	maxage: ${14:20}
	vlanid: ${15:# This is only used with VLAN - VLAN ID in range <0-4095>}
	priority: ${16:128}
	gw4: ${17:# The IPv4 gateway for this interface using this format ie: "192.0.2.1"}
	gw6: ${18:# The IPv6 gateway for this interface using this format ie: "2001:db8::1"}
	master: ${19:# master <master (ifname, or connection UUID or conn_name) of bridge, team, bond master connection profile.}
	stp: ${20:# This is only used with bridge and controls whether Spanning Tree Protocol (STP) is enabled for this bridge}
	ifname: ${21:conn_name}
	type: ${22:ethernet|team|team-slave|bond|bond-slave|bridge|vlan}
	miimon: ${23:100}
	hellotime: ${24:2}
	downdelay: ${25:# This is only used with bond - downdelay}
	mac: ${26:# This is only used with bridge - MAC address of the bridge (note: this requires a recent kernel feature, originally introduced in 3.15 upstream kernel)}
	ip6: ${27:# The IPv6 address to this interface using this format ie: "abbe::cafe"}
	ip4: ${28:# The IPv4 address to this interface using this format ie: "192.0.2.24/24"}
	autoconnect: ${29:#yes|no}
	dns6: ${30:# A list of upto 3 dns servers, ipv6 format e.g. To add two IPv6 DNS server addresses: ["2001:4860:4860::8888 2001:4860:4860::8844"]}
	mtu: ${31:1500}
	arp_interval: ${32:# This is only used with bond - ARP interval}
	flags: ${33:# This is only used with VLAN - flags}
	mode: ${34:balance-rr|active-backup|balance-xor|broadcast|802.3ad|balance-tlb|balance-alb}
	updelay: ${35:# This is only used with bond - updelay}

endsnippet

snippet bigip_vlan "Manage VLANs on a BIG-IP system" b
bigip_vlan:
	name: ${1:# The VLAN to manage. If the special VLAN C(ALL) is specified with the C(state) value of C(absent) then all VLANs will be removed.}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	untagged_interfaces: ${5:# Specifies a list of untagged interfaces and trunks that you want to configure for the VLAN.}
	server_port: ${6:443}
	state: ${7:absent|#present}
	tag: ${8:# Tag number for the VLAN. The tag number can be any integer between 1 and 4094. The system automatically assigns a tag number if you do not specify a value.}
	tagged_interfaces: ${9:# Specifies a list of tagged interfaces and trunks that you want to configure for the VLAN. Use tagged interfaces or trunks when you want to assign a single interface or trunk to multiple VLANs.}
	validate_certs: ${10:#True|False}
	description: ${11:# The description to give to the VLAN.}

endsnippet

snippet bigip_device_sshd "Manage the SSHD settings of a BIG-IP" b
bigip_device_sshd:
	server: ${1:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	log_level: ${4:debug|debug1|debug2|debug3|error|fatal|info|quiet|verbose}
	server_port: ${5:443}
	banner_text: ${6:# Specifies the text to include on the pre-login banner that displays when a user attempts to login to the system using SSH.}
	validate_certs: ${7:#True|False}
	allow: ${8:all|IP address, such as 172.27.1.10|IP range, such as 172.27.*.* or 172.27.0.0/255.255.0.0}
	inactivity_timeout: ${9:# Specifies the number of seconds before inactivity causes an SSH session to log out.}
	login: ${10:enabled|disabled}
	banner: ${11:enabled|disabled}
	port: ${12:# Port that you want the SSH daemon to run on.}

endsnippet

snippet bigip_pool "Manages F5 BIG-IP LTM pools" b
bigip_pool:
	name: ${1:}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	lb_method: ${5:#round_robin|ratio_member|least_connection_member|observed_member|predictive_member|ratio_node_address|least_connection_node_address|fastest_node_address|observed_node_address|predictive_node_address|dynamic_ratio|fastest_app_response|least_sessions|dynamic_ratio_member|l3_addr|weighted_least_connection_member|weighted_least_connection_node_address|ratio_session|ratio_least_connection_member|ratio_least_connection_node_address}
	description: ${6:# Specifies descriptive text that identifies the pool.}
	partition: ${7:}
	slow_ramp_time: ${8:}
	state: ${9:#present|absent}
	service_down_action: ${10:none|reset|drop|reselect}
	reselect_tries: ${11:}
	port: ${12:}
	monitor_type: ${13:and_list|m_of_n}
	host: ${14:}
	server_port: ${15:443}
	validate_certs: ${16:#True|False}
	monitors: ${17:}
	quorum: ${18:}

endsnippet

snippet bigip_monitor_tcp "Manages F5 BIG-IP LTM tcp monitors" b
bigip_monitor_tcp:
	password: ${1:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	name: ${2:# Monitor name}
	receive: ${3:none}
	send: ${4:none}
	server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}

	partition: ${7:Common}
	parent: ${8:#tcp|tcp_echo|tcp_half_open}
	ip: ${9:none}
	interval: ${10:none}
	server_port: ${11:443}
	validate_certs: ${12:#True|False}
	state: ${13:#present|absent}
	time_until_up: ${14:none}
	timeout: ${15:none}
	parent_partition: ${16:Common}
	type: ${17:TTYPE_TCP|TTYPE_TCP_ECHO|TTYPE_TCP_HALF_OPEN}
	port: ${18:none}

endsnippet

snippet bigip_device_ntp "Manage NTP servers on a BIG-IP" b
bigip_device_ntp:
	server: ${1:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	ntp_servers: ${4:[]}
	state: ${5:absent|#present}
	server_port: ${6:443}
	timezone: ${7:UTC}
	validate_certs: ${8:#True|False}

endsnippet

snippet bigip_gtm_wide_ip "Manages F5 BIG-IP GTM wide ip" b
bigip_gtm_wide_ip:
	lb_method: ${1:return_to_dns|null|round_robin|ratio|topology|static_persist|global_availability|vs_capacity|least_conn|lowest_rtt|lowest_hops|packet_rate|cpu|hit_ratio|qos|bps|drop_packet|explicit_ip|connection_rate|vs_score}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	wide_ip: ${4:# Wide IP name}
	server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}

	server_port: ${6:443}
	validate_certs: ${7:#True|False}

endsnippet

snippet bigip_selfip "Manage Self-IPs on a BIG-IP system" b
bigip_selfip:
	name: ${1:Value of C(address)}
	vlan: ${2:# The VLAN that the new self IPs will be on.}
	netmask: ${3:# The netmasks for the self IP.}
	server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	allow_service: ${7:# Configure port lockdown for the Self IP. By default, the Self IP has a "default deny" policy. This can be changed to allow TCP and UDP ports as well as specific protocols. This list should contain C(protocol):C(port) values.}
	state: ${8:absent|#present}
	route_domain: ${9:none}
	server_port: ${10:443}
	address: ${11:# The IP addresses for the new self IP. This value is ignored upon update as addresses themselves cannot be changed after they are created.}
	traffic_group: ${12:# The traffic group for the self IP addresses in an active-active, redundant load balancer configuration.}
	validate_certs: ${13:#True|False}

endsnippet

snippet bigip_sys_db "Manage BIG-IP system database variables" b
bigip_sys_db:
	server: ${1:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	key: ${3:# The database variable to manipulate.}
	password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	server_port: ${5:443}
	value: ${6:# The value to set the key to. At least one of value and state C(reset) are required.}
	state: ${7:#present|reset}
	validate_certs: ${8:#True|False}

endsnippet

snippet bigip_pool_member "Manages F5 BIG-IP LTM pool members" b
bigip_pool_member:
	state: ${1:#present|absent}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	host: ${3:# Pool member IP}
	user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	port: ${6:# Pool member port}
	pool: ${7:# Pool name. This pool must exist.}

	session_state: ${8:enabled|disabled}
	ratio: ${9:# Pool member ratio weight. Valid values range from 1 through 100. New pool members -- unless overridden with this value -- default to 1.}
	description: ${10:# Pool member description}
	monitor_state: ${11:enabled|disabled}
	partition: ${12:Common}
	connection_limit: ${13:# Pool member connection limit. Setting this to 0 disables the limit.}
	preserve_node: ${14:True|False}
	server_port: ${15:443}
	rate_limit: ${16:# Pool member rate limit (connections-per-second). Setting this to 0 disables the limit.}
	validate_certs: ${17:#True|False}

endsnippet

snippet bigip_sys_global "Manage BIG-IP global settings." b
bigip_sys_global:
	server: ${1:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	security_banner: ${4:enabled|disabled}
	net_reboot: ${5:enabled|disabled}
	banner_text: ${6:# Specifies the text to present in the advisory banner.}
	console_timeout: ${7:# Specifies the number of seconds of inactivity before the system logs off a user that is logged on.}
	quiet_boot: ${8:# Specifies, when C(enabled), that the system suppresses informational text on the console during the boot cycle. When C(disabled), the system presents messages and informational text on the console during the boot cycle.}
	mgmt_dhcp: ${9:enabled|disabled}
	state: ${10:#present}
	server_port: ${11:443}
	gui_setup: ${12:enabled|disabled}
	validate_certs: ${13:#True|False}
	lcd_display: ${14:enabled|disabled}

endsnippet

snippet bigip_monitor_http "Manages F5 BIG-IP LTM http monitors" b
bigip_monitor_http:
	password: ${1:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	name: ${2:# Monitor name}
	receive: ${3:none}
	send: ${4:none}
	server: ${5:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${6:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	receive_disable: ${7:none}

	partition: ${8:Common}
	parent: ${9:http}
	ip: ${10:none}
	interval: ${11:none}
	server_port: ${12:443}
	state: ${13:#present|absent}
	time_until_up: ${14:none}
	timeout: ${15:none}
	parent_partition: ${16:Common}
	validate_certs: ${17:#True|False}
	port: ${18:none}

endsnippet

snippet bigip_hostname "Manage the hostname of a BIG-IP." b
bigip_hostname:
	password: ${1:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	hostname: ${3:# Hostname of the BIG-IP host.}
	server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}

	server_port: ${5:443}
	validate_certs: ${6:#True|False}

endsnippet

snippet bigip_gtm_virtual_server "Manages F5 BIG-IP GTM virtual servers" b
bigip_gtm_virtual_server:
	virtual_server_name: ${1:# Virtual server name}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	virtual_server_server: ${5:# Virtual server server}

	validate_certs: ${6:#True|False}
	state: ${7:#present|absent|enabled|disabled}
	host: ${8:# Virtual server host}
	server_port: ${9:443}
	port: ${10:# Virtual server port}

endsnippet

snippet bigip_routedomain "Manage route domains on a BIG-IP" b
bigip_routedomain:
	password: ${1:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	id: ${3:# The unique identifying integer representing the route domain.}
	user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}

	flow_eviction_policy: ${5:# The eviction policy to use with this route domain. Apply an eviction policy to provide customized responses to flow overflows and slow flows on the route domain.}
	service_policy: ${6:# Service policy to associate with the route domain.}
	description: ${7:# Specifies descriptive text that identifies the route domain.}
	parent: ${8:# S}
	connection_limit: ${9:# The maximum number of concurrent connections allowed for the route domain. Setting this to C(0) turns off connection limits.}
	strict: ${10:enabled|disabled}
	state: ${11:#present|absent}
	routing_protocol: ${12:BFD|BGP|IS-IS|OSPFv2|OSPFv3|PIM|RIP|RIPng}
	server_port: ${13:443}
	bwc_policy: ${14:# The bandwidth controller for the route domain.}
	vlans: ${15:# VLANs for the system to use in the route domain}
	validate_certs: ${16:#True|False}

endsnippet

snippet bigip_gtm_facts "Collect facts from F5 BIG-IP GTM devices." b
bigip_gtm_facts:
	password: ${1:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	include: ${3:pool|wide_ip|virtual_server}
	server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}

	filter: ${5:# Perform regex filter of response. Filtering is done on the name of the resource. Valid filters are anything that can be provided to Python's C(re) module.}
	server_port: ${6:443}
	validate_certs: ${7:#True|False}

endsnippet

snippet bigip_gtm_datacenter "Manage Datacenter configuration in BIG-IP" b
bigip_gtm_datacenter:
	user: ${1:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	name: ${4:# The name of the data center.}

	description: ${5:# The description of the data center.}
	enabled: ${6:True|False}
	state: ${7:present|absent}
	contact: ${8:# The name of the contact for the data center.}
	location: ${9:# The location of the data center.}
	server_port: ${10:443}
	validate_certs: ${11:#True|False}

endsnippet

snippet bigip_virtual_server "Manages F5 BIG-IP LTM virtual servers" b
bigip_virtual_server:
	user: ${1:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	destination: ${2:# Destination IP of the virtual server (only host is currently supported). Required when state=present and vs does not exist.}
	name: ${3:# Virtual server name}
	server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	route_advertisement_state: ${6:disabled}
	fallback_persistence_profile: ${7:# Specifies the persistence profile you want the system to use if it cannot use the specified default persistence profile.}
	validate_certs: ${8:#True|False}
	default_persistence_profile: ${9:# Default Profile which manages the session persistence}
	partition: ${10:Common}
	all_profiles: ${11:# List of all Profiles (HTTP,ClientSSL,ServerSSL,etc) that must be used by the virtual server}
	all_rules: ${12:# List of rules to be applied in priority order}
	enabled_vlans: ${13:# List of vlans to be enabled. When a VLAN named C(ALL) is used, all VLANs will be allowed.}
	state: ${14:#present|absent|enabled|disabled}
	all_policies: ${15:# List of all policies enabled for the virtual server.}
	server_port: ${16:443}
	snat: ${17:#None|Automap|Name of a SNAT pool (eg "/Common/snat_pool_name") to enable SNAT with the specific pool}
	port: ${18:# Port of the virtual server. Required when state=present and vs does not exist. If you specify a value for this field, it must be a number between 0 and 65535.}
	pool: ${19:# Default pool for the virtual server}
	description: ${20:# Virtual server description}

endsnippet

snippet bigip_snat_pool "Manage SNAT pools on a BIG-IP." b
bigip_snat_pool:
	name: ${1:# T}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${4:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	server_port: ${5:443}
	state: ${6:#present|absent}
	members: ${7:# List of members to put in the SNAT pool. When a C(state) of present is provided, this parameter is required. Otherwise, it is optional.}
	validate_certs: ${8:#True|False}
	append: ${9:True|#False}

endsnippet

snippet bigip_irule "Manage iRules across different modules on a BIG-IP." b
bigip_irule:
	src: ${1:# The iRule file to interpret and upload to the BIG-IP. Either one of C(src) or C(content) must be provided.}
	name: ${2:# The name of the iRule.}
	module: ${3:ltm|gtm}
	server: ${4:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${6:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	partition: ${7:Common}
	content: ${8:# When used instead of 'src', sets the contents of an iRule directly to the specified value. This is for simple values, but can be used with lookup plugins for anything complex or with formatting. Either one of C(src) or C(content) must be provided.}
	state: ${9:#present|absent}
	server_port: ${10:443}
	validate_certs: ${11:#True|False}

endsnippet

snippet bigip_ssl_certificate "Import/Delete certificates from BIG-IP" b
bigip_ssl_certificate:
	name: ${1:# SSL Certificate Name.  This is the cert/key pair name used when importing a certificate/key into the F5. It also determines the filenames of the objects on the LTM (:Partition:name.cer_11111_1 and :Partition_name.key_11111_1).}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	state: ${3:#present|absent}
	user: ${4:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${5:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	validate_certs: ${6:#True|False}
	key_content: ${7:# When used instead of 'key_src', sets the contents of a certificate key directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
	partition: ${8:Common}
	server_port: ${9:443}
	cert_src: ${10:# This is the local filename of the certificate. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
	passphrase: ${11:# Passphrase on certificate private key}
	cert_content: ${12:# When used instead of 'cert_src', sets the contents of a certificate directly to the specified value. This is used with lookup plugins or for anything with formatting or templating. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}
	key_src: ${13:# This is the local filename of the private key. Either one of C(key_src), C(key_content), C(cert_src) or C(cert_content) must be provided when C(state) is C(present).}

endsnippet

snippet bigip_device_dns "Manage BIG-IP device DNS settings" b
bigip_device_dns:
	server: ${1:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${2:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	password: ${3:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}

	search: ${4:# A list of domains that the system searches for local domain lookups, to resolve local host names.}
	cache: ${5:enable|#disable}
	ip_version: ${6:4|6}
	state: ${7:absent|#present}
	server_port: ${8:443}
	forwarders: ${9:# A list of BIND servers that the system can use to perform DNS lookups}
	name_servers: ${10:# A list of name serverz that the system uses to validate DNS lookups}
	validate_certs: ${11:#True|False}

endsnippet

snippet bigip_node "Manages F5 BIG-IP LTM nodes" b
bigip_node:
	password: ${1:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	state: ${2:#present|absent}
	server: ${3:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	host: ${4:}
	user: ${5:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}

	session_state: ${6:enabled|disabled}
	name: ${7:}
	monitor_state: ${8:enabled|disabled}
	partition: ${9:}
	monitor_type: ${10:and_list|m_of_n}
	server_port: ${11:443}
	quorum: ${12:}
	validate_certs: ${13:#True|False}
	monitors: ${14:}
	description: ${15:}

endsnippet

snippet bigip_facts "Collect facts from F5 BIG-IP devices" b
bigip_facts:
	password: ${1:# The password for the user account used to connect to the BIG-IP. This option can be omitted if the environment variable C(F5_PASSWORD) is set.}
	server: ${2:# The BIG-IP host. This option can be omitted if the environment variable C(F5_SERVER) is set.}
	user: ${3:# The username to connect to the BIG-IP with. This user must have administrative privileges on the device. This option can be omitted if the environment variable C(F5_USER) is set.}
	include: ${4:address_class|certificate|client_ssl_profile|device|device_group|interface|key|node|pool|provision|rule|self_ip|software|system_info|traffic_group|trunk|virtual_address|virtual_server|vlan}

	filter: ${5:}
	session: ${6:}
	server_port: ${7:443}
	validate_certs: ${8:#True|False}

endsnippet

snippet uri "Interacts with webservices" b
uri:
	url: ${1:# HTTP or HTTPS URL in the form (http|https)://host.domain[:port]/path}

	body: ${2:# The body of the http request/response to the web service. If C(body_format) is set to 'json' it will take an already formatted JSON string or convert a data structure into JSON.}
	dest: ${3:# path of where to download the file to (if desired). If I(dest) is a directory, the basename of the file on the remote server will be used.}
	follow_redirects: ${4:all|#safe|none}
	force_basic_auth: ${5:yes|#no}
	removes: ${6:# a filename, when it does not exist, this step will not be run.}
	user: ${7:# username for the module to use for Digest, Basic or WSSE authentication.}
	others: ${8:# all arguments accepted by the M(file) module also work here}
	body_format: ${9:#raw|json}
	password: ${10:# password for the module to use for Digest, Basic or WSSE authentication.}
	HEADER_: ${11:# Any parameter starting with "HEADER_" is a sent with your request as a header. For example, HEADER_Content-Type="application/json" would send the header "Content-Type" along with your request with a value of "application/json". This option is deprecated as of C(2.1) and may be removed in a future release. Use I(headers) instead.}
	creates: ${12:# a filename, when it already exists, this step will not be run.}
	headers: ${13:# Add custom HTTP headers to a request in the format of a YAML hash. As of C(2.3) supplying C(Content-Type) here will override the header generated by supplying C(json) for I(body_format).}
	timeout: ${14:30}
	status_code: ${15:200}
	return_content: ${16:yes|#no}
	validate_certs: ${17:#yes|no}
	method: ${18:#GET|POST|PUT|HEAD|DELETE|OPTIONS|PATCH|TRACE|CONNECT|REFRESH}

endsnippet

snippet get_url "Downloads files from HTTP, HTTPS, or FTP to node" b
get_url:
	dest: ${1:# absolute path of where to download the file to.}
	url: ${2:# HTTP, HTTPS, or FTP URL in the form (http|https|ftp)://[user[:pass]]@host.domain[:port]/path}

	force: ${3:yes|#no}
	url_username: ${4:# The username for use in HTTP basic authentication. This parameter can be used without C(url_password) for sites that allow empty passwords.}
	validate_certs: ${5:#yes|no}
	selevel: ${6:s0}
	force_basic_auth: ${7:yes|#no}
	sha256sum: ${8:# If a SHA-256 checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. This option is deprecated. Use 'checksum'.}
	others: ${9:# all arguments accepted by the M(file) module also work here}
	owner: ${10:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	url_password: ${11:# The password for use in HTTP basic authentication. If the C(url_username) parameter is not specified, the C(url_password) parameter will not be used.}
	unsafe_writes: ${12:no}
	group: ${13:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	use_proxy: ${14:#yes|no}
	checksum: ${15:# If a checksum is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully. Format: <algorithm>:<checksum>, e.g.: checksum="sha256:D98291AC[...]B6DC7B97" If you worry about portability, only the sha1 algorithm is available on all platforms and python versions.  The third party hashlib library can be installed for access to additional algorithms. Additionally, if a checksum is passed to this parameter, and the file exist under the C(dest) location, the destination_checksum would be calculated, and if checksum equals destination_checksum, the file download would be skipped (unless C(force) is true). }
	seuser: ${16:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	setype: ${17:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
	headers: ${18:# Add custom HTTP headers to a request in the format "key:value,key:value"}
	serole: ${19:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	mode: ${20:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	timeout: ${21:10}
	attributes: ${22:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	backup: ${23:yes|#no}
	tmp_dest: ${24:}

endsnippet

snippet slurp "Slurps a file from remote nodes" b
slurp:
	src: ${1:# The file on the remote system to fetch. This I(must) be a file, not a directory.}

endsnippet

snippet docker_service "Manage docker services and containers." b
docker_service:
	files: ${1:# List of file names relative to C(project_src). Overrides docker-compose.yml or docker-compose.yaml.}
	project_name: ${2:# Provide a project name. If not provided, the project name is taken from the basename of C(project_src).}
	project_src: ${3:# Path to a directory containing a docker-compose.yml or docker-compose.yaml file.}
	hostname_check: ${4:no}
	recreate: ${5:always|never|#smart}
	tls_hostname: ${6:localhost}
	docker_host: ${7:unix://var/run/docker.sock}
	dependencies: ${8:yes}
	remove_images: ${9:# Use with state I(absent) to remove the all images or only local images.}
	services: ${10:# When C(state) is I(present) run I(docker-compose up) on a subset of services.}
	cert_path: ${11:# Path to the client's TLS certificate file.}
	pull: ${12:no}
	tls: ${13:no}
	definition: ${14:# Provide docker-compose yaml describing one or more services, networks and volumes.}
	scale: ${15:# When C(state) is I(present) scale services. Provide a dictionary of key/value pairs where the key is the name of the service and the value is an integer count for the number of containers.}
	nocache: ${16:no}
	restarted: ${17:no}
	ssl_version: ${18:1.0}
	state: ${19:absent|#present}
	api_version: ${20:default provided by docker-py}
	remove_volumes: ${21:no}
	tls_verify: ${22:no}
	stopped: ${23:no}
	build: ${24:no}
	timeout: ${25:60}
	debug: ${26:no}
	cacert_path: ${27:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	key_path: ${28:# Path to the client's TLS key file.}

endsnippet

snippet docker_image "Manage docker images." b
docker_image:
	name: ${1:# Image name. Name format will be one of: name, repository/name, registry_server:port/name. When pushing or pulling an image the name can optionally include the tag by appending ':tag_name'.}

	archive_path: ${2:# Use with state C(present) to archive an image to a .tar file.}
	cacert_path: ${3:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	force: ${4:no}
	timeout: ${5:60}
	repository: ${6:# Full path to a repository. Use with state C(present) to tag the image into the repository. Expects format I(repository:tag). If no tag is provided, will use the value of the C(tag) parameter or I(latest).}
	tls_hostname: ${7:localhost}
	docker_host: ${8:unix://var/run/docker.sock}
	tag: ${9:latest}
	cert_path: ${10:# Path to the client's TLS certificate file.}
	path: ${11:# Use with state 'present' to build an image. Will be the path to a directory containing the context and Dockerfile for building an image.}
	tls: ${12:no}
	pull: ${13:yes}
	nocache: ${14:no}
	container_limits: ${15:# A dictionary of limits applied to each container created by the build process.}
	http_timeout: ${16:# Timeout for HTTP requests during the image build operation. Provide a positive integer value for the number of seconds.}
	ssl_version: ${17:1.0}
	load_path: ${18:# Use with state C(present) to load an image from a .tar file.}
	use_tls: ${19:#False|encrypt|verify}
	state: ${20:absent|#present|build}
	tls_verify: ${21:no}
	key_path: ${22:# Path to the client's TLS key file.}
	buildargs: ${23:# Provide a dictionary of C(key:value) build arguments that map to Dockerfile ARG directive.}
	push: ${24:no}
	rm: ${25:yes}
	dockerfile: ${26:Dockerfile}
	api_version: ${27:default provided by docker-py}

endsnippet

snippet docker_container "manage docker containers" b
docker_container:
	name: ${1:# Assign a name to a new container or match an existing container.}

	tty: ${2:no}
	dns_servers: ${3:# List of custom DNS servers.}
	image: ${4:# Repository path and tag used to create the container. If an image is not found or pull is true, the image will be pulled from the registry. If no tag is included, 'latest' will be used.}
	labels: ${5:# Dictionary of key value pairs.}
	docker_host: ${6:unix://var/run/docker.sock}
	cpuset_cpus: ${7:# CPUs in which to allow execution C(1,3) or C(1-3).}
	force_kill: ${8:no}
	pid_mode: ${9:# Set the PID namespace mode for the container. Currently only supports 'host'.}
	networks: ${10:# List of networks the container belongs to.}
	cpu_period: ${11:0}
	capabilities: ${12:# List of capabilities to add to the container.}
	memory_swap: ${13:0}
	mac_address: ${14:# Container MAC address (e.g. 92:d0:c6:0a:29:33)}
	volumes_from: ${15:# List of container names or Ids to get volumes from.}
	log_options: ${16:# Dictionary of options specific to the chosen log_driver. See https://docs.docker.com/engine/admin/logging/overview/ for details.}
	recreate: ${17:no}
	memory: ${18:0}
	memory_swappiness: ${19:0}
	network_mode: ${20:bridge|container:<name|id>|host|none}
	detach: ${21:yes}
	published_ports: ${22:# List of ports to publish from the container to the host.}
	restart: ${23:no}
	pull: ${24:no}
	stop_signal: ${25:# Override default signal used to stop the container.}
	devices: ${26:# List of host device bindings to add to the container. Each binding is a mapping expressed in the format: <path_on_host>:<path_in_container>:<cgroup_permissions>}
	uts: ${27:# Set the UTS namespace mode for the container.}
	blkio_weight: ${28:# Block IO (relative weight), between 10 and 1000.}
	timeout: ${29:60}
	stop_timeout: ${30:# Number of seconds to wait for the container to stop before sending SIGKILL.}
	ulimits: ${31:# List of ulimit options. A ulimit is specified as C(nofile:262144:262144)}
	interactive: ${32:no}
	links: ${33:# List of name aliases for linked containers in the format C(container_name:alias)}
	oom_score_adj: ${34:0}
	ssl_version: ${35:1.0}
	command: ${36:# Command to execute when the container starts.}
	paused: ${37:no}
	tls_verify: ${38:no}
	dns_search_domains: ${39:# List of custom DNS search domains.}
	security_opts: ${40:# List of security options in the form of C("label:user:User")}
	env_file: ${41:# Path to a file containing environment variables I(FOO=BAR).}
	cpu_quota: ${42:0}
	read_only: ${43:no}
	cpuset_mems: ${44:# Memory nodes (MEMs) in which to allow execution C(0-3) or C(0,1)}
	hostname: ${45:# Container hostname.}
	state: ${46:absent|present|stopped|#started}
	cleanup: ${47:no}
	entrypoint: ${48:# Command that overwrites the default ENTRYPOINT of the image.}
	key_path: ${49:# Path to the client's TLS key file.}
	env: ${50:# Dictionary of key,value pairs.}
	keep_volumes: ${51:yes}
	ipc_mode: ${52:# Set the IPC mode for the container. Can be one of 'container:<name|id>' to reuse another container's IPC namespace or 'host' to use the host's IPC namespace within the container.}
	privileged: ${53:no}
	api_version: ${54:default provided by docker-py}
	exposed_ports: ${55:# List of additional container ports which informs Docker that the container listens on the specified network ports at runtime. If the port is already exposed using EXPOSE in a Dockerfile, it does not need to be exposed again.}
	trust_image_content: ${56:no}
	cacert_path: ${57:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	log_driver: ${58:none|json-file|syslog|journald|gelf|fluentd|awslogs|splunk}
	oom_killer: ${59:no}
	shm_size: ${60:# Size of `/dev/shm`. The format is `<number><unit>`. `number` must be greater than `0`. Unit is optional and can be `b` (bytes), `k` (kilobytes), `m` (megabytes), or `g` (gigabytes).}
	kill_signal: ${61:# Override default signal used to kill a running container.}
	tls_hostname: ${62:localhost}
	volume_driver: ${63:none}
	user: ${64:# Sets the username or UID used and optionally the groupname or GID for the specified command.}
	groups: ${65:# List of additional group names and/or IDs that the container process will run as.}
	cert_path: ${66:# Path to the client's TLS certificate file.}
	purge_networks: ${67:no}
	tls: ${68:no}
	ignore_image: ${69:no}
	restart_policy: ${70:always|False|#on-failure|unless-stopped}
	kernel_memory: ${71:0}
	etc_hosts: ${72:# Dict of host-to-IP mappings, where each host name is a key in the dictionary. Each host name will be added to the container's /etc/hosts file.}
	memory_reservation: ${73:0}
	volumes: ${74:# List of volumes to mount within the container.}
	cpu_shares: ${75:# CPU shares (relative weight).}
	restart_retries: ${76:0}

endsnippet

snippet docker_image_facts "Inspect docker images" b
docker_image_facts:
	name: ${1:# An image name or a list of image names. Name format will be name[:tag] or repository/name[:tag], where tag is optional. If a tag is not provided, 'latest' will be used.}

	tls: ${2:no}
	cacert_path: ${3:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	ssl_version: ${4:1.0}
	tls_hostname: ${5:localhost}
	docker_host: ${6:unix://var/run/docker.sock}
	tls_verify: ${7:no}
	key_path: ${8:# Path to the client's TLS key file.}
	timeout: ${9:60}
	cert_path: ${10:# Path to the client's TLS certificate file.}
	api_version: ${11:default provided by docker-py}

endsnippet

snippet docker_login "Log into a Docker registry." b
docker_login:
	username: ${1:# The username for the registry account}
	password: ${2:# The plaintext password for the registry account}

	cacert_path: ${3:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	tls_hostname: ${4:localhost}
	docker_host: ${5:unix://var/run/docker.sock}
	tls_verify: ${6:no}
	cert_path: ${7:# Path to the client's TLS certificate file.}
	tls: ${8:no}
	config_path: ${9:~/.docker/config.json}
	ssl_version: ${10:1.0}
	state: ${11:#present|absent}
	key_path: ${12:# Path to the client's TLS key file.}
	timeout: ${13:60}
	registry_url: ${14:https://index.docker.io/v1/}
	email: ${15:# The email address for the registry account. NOTE: private registries may not require this, but Docker Hub requires it.}
	api_version: ${16:default provided by docker-py}
	reauthorize: ${17:yes|no}

endsnippet

snippet docker_network "Manage Docker networks" b
docker_network:
	name: ${1:# Name of the network to operate on.}

	tls: ${2:no}
	cacert_path: ${3:# Use a CA certificate when performing server verification by providing the path to a CA certificate file.}
	force: ${4:no}
	tls_verify: ${5:no}
	ssl_version: ${6:1.0}
	driver: ${7:bridge}
	docker_host: ${8:unix://var/run/docker.sock}
	ipam_options: ${9:# Dictionary of IPAM options.}
	tls_hostname: ${10:localhost}
	state: ${11:absent|#present}
	driver_options: ${12:# Dictionary of network settings. Consult docker docs for valid options and values.}
	connected: ${13:# List of container names or container IDs to connect to a network.}
	key_path: ${14:# Path to the client's TLS key file.}
	timeout: ${15:60}
	cert_path: ${16:# Path to the client's TLS certificate file.}
	ipam_driver: ${17:# Specify an IPAM driver.}
	appends: ${18:no}
	api_version: ${19:default provided by docker-py}

endsnippet

snippet vmware_guest_facts "Gather facts about a single Virtual Machine" b
vmware_guest_facts:
	username: ${1:# The username of the vSphere vCenter.}
	datacenter: ${2:# Destination datacenter for the deploy operation}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	password: ${4:# The password of the vSphere vCenter.}
	name: ${5:# Name of the Virtual Machine to work with}

	uuid: ${6:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	name_match: ${7:#first|last}
	folder: ${8:/vm}
	validate_certs: ${9:#True|False}

endsnippet

snippet vmware_datacenter "Manage VMware vSphere Datacenters" b
vmware_datacenter:
	username: ${1:# The username of the vSphere vCenter.}
	datacenter_name: ${2:# The name of the datacenter the cluster will be created in.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	password: ${4:# The password of the vSphere vCenter.}

	state: ${5:#present|absent}
	validate_certs: ${6:#True|False}

endsnippet

snippet vsphere_copy "Copy a file to a vCenter datastore" b
vsphere_copy:
	src: ${1:# The file to push to vCenter}
	datacenter: ${2:# The datacenter on the vCenter server that holds the datastore.}
	host: ${3:# The vCenter server on which the datastore is available.}
	path: ${4:# The file to push to the datastore on the vCenter server.}
	login: ${5:# The login name to authenticate on the vCenter server.}
	password: ${6:# The password to authenticate on the vCenter server.}
	datastore: ${7:# The datastore on the vCenter server to push files to.}

	validate_certs: ${8:#yes|no}

endsnippet

snippet vmware_vswitch "Add a VMware Standard Switch to an ESXi host" b
vmware_vswitch:
	username: ${1:# The username of the vSphere vCenter.}
	password: ${2:# The password of the vSphere vCenter.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	nic_name: ${4:# vmnic name to attach to vswitch}
	switch_name: ${5:# vSwitch name to add}

	mtu: ${6:# MTU to configure on vswitch}
	state: ${7:#present|absent}
	number_of_ports: ${8:128}
	validate_certs: ${9:#True|False}

endsnippet

snippet vmware_migrate_vmk "Migrate a VMK interface from VSS to VDS" b
vmware_migrate_vmk:
	username: ${1:# The username of the vSphere vCenter.}
	password: ${2:# The password of the vSphere vCenter.}
	current_switch_name: ${3:# Switch VMK interface is currently on}
	migrate_portgroup_name: ${4:# Portgroup name to migrate VMK interface to}
	esxi_hostname: ${5:# ESXi hostname to be managed}
	device: ${6:# VMK interface name}
	migrate_switch_name: ${7:# Switch name to migrate VMK interface to}
	current_portgroup_name: ${8:# Portgroup name VMK interface is currently on}
	hostname: ${9:# The hostname or IP address of the vSphere vCenter.}

	validate_certs: ${10:#True|False}

endsnippet

snippet vmware_vm_facts "Return basic facts pertaining to a vSphere virtual machine guest" b
vmware_vm_facts:
	username: ${1:# The username of the vSphere vCenter.}
	password: ${2:# The password of the vSphere vCenter.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}

	validate_certs: ${4:#True|False}

endsnippet

snippet vmware_vm_shell "Execute a process in VM" b
vmware_vm_shell:
	username: ${1:# The username of the vSphere vCenter.}
	vm_shell: ${2:# The absolute path to the program to start. On Linux this is executed via bash.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	password: ${4:# The password of the vSphere vCenter.}
	vm_id: ${5:# The identification for the VM}

	datacenter: ${6:# The datacenter hosting the VM}
	vm_password: ${7:# The password used to login to the VM.}
	vm_shell_cwd: ${8:# The current working directory of the application from which it will be run}
	vm_shell_args: ${9:# The argument to the program.}
	vm_username: ${10:# The user to connect to the VM.}
	vm_shell_env: ${11:# Comma separated list of envirnoment variable, specified in the guest OS notation}
	cluster: ${12:# The cluster hosting the VM}
	vm_id_type: ${13:uuid|dns_name|inventory_path|#vm_name}
	validate_certs: ${14:#True|False}

endsnippet

snippet vmware_dvs_host "Add or remove a host from distributed virtual switch" b
vmware_dvs_host:
	username: ${1:# The username of the vSphere vCenter.}
	hostname: ${2:# The hostname or IP address of the vSphere vCenter.}
	state: ${3:present|absent}
	esxi_hostname: ${4:# The ESXi hostname}
	password: ${5:# The password of the vSphere vCenter.}
	vmnics: ${6:# The ESXi hosts vmnics to use with the Distributed vSwitch}
	switch_name: ${7:# The name of the Distributed vSwitch}

	validate_certs: ${8:#True|False}

endsnippet

snippet vmware_local_user_manager "Manage local users on an ESXi host" b
vmware_local_user_manager:
	username: ${1:# The username of the vSphere vCenter.}
	hostname: ${2:# The hostname or IP address of the vSphere vCenter.}
	password: ${3:# The password of the vSphere vCenter.}
	local_user_name: ${4:# The local user name to be changed}

	local_user_description: ${5:# Description for the user}
	local_user_password: ${6:# The password to be set}
	state: ${7:#present|absent}
	validate_certs: ${8:#True|False}

endsnippet

snippet vmware_cluster "Create VMware vSphere Cluster" b
vmware_cluster:
	username: ${1:# The username of the vSphere vCenter.}
	datacenter_name: ${2:# The name of the datacenter the cluster will be created in.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	cluster_name: ${4:# The name of the cluster that will be created}
	password: ${5:# The password of the vSphere vCenter.}

	enable_ha: ${6:no}
	enable_vsan: ${7:no}
	enable_drs: ${8:no}
	validate_certs: ${9:#True|False}

endsnippet

snippet vmware_vm_vss_dvs_migrate "Migrates a virtual machine from a standard vswitch to distributed" b
vmware_vm_vss_dvs_migrate:
	vm_name: ${1:# Name of the virtual machine to migrate to a dvSwitch}
	username: ${2:# The username of the vSphere vCenter.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	dvportgroup_name: ${4:# Name of the portgroup to migrate to the virtual machine to}
	password: ${5:# The password of the vSphere vCenter.}

	validate_certs: ${6:#True|False}

endsnippet

snippet vmware_vmotion "Move a virtual machine using vMotion" b
vmware_vmotion:
	vm_name: ${1:# Name of the VM to perform a vMotion on}
	username: ${2:# The username of the vSphere vCenter.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	password: ${4:# The password of the vSphere vCenter.}
	destination_host: ${5:# Name of the end host the VM should be running on}

	validate_certs: ${6:#True|False}

endsnippet

snippet vmware_dns_config "Manage VMware ESXi DNS Configuration" b
vmware_dns_config:
	username: ${1:# The username of the vSphere vCenter.}
	dns_servers: ${2:# The DNS servers that the host should be configured to use.}
	domainname: ${3:# The domain the ESXi host should be apart of.}
	change_hostname_to: ${4:# The hostname that an ESXi host should be changed to.}
	password: ${5:# The password of the vSphere vCenter.}
	hostname: ${6:# The hostname or IP address of the vSphere vCenter.}

	validate_certs: ${7:#True|False}

endsnippet

snippet vmware_dvs_portgroup "Create or remove a Distributed vSwitch portgroup" b
vmware_dvs_portgroup:
	username: ${1:# The username of the vSphere vCenter.}
	portgroup_name: ${2:# The name of the portgroup that is to be created or deleted}
	password: ${3:# The password of the vSphere vCenter.}
	hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
	num_ports: ${5:# The number of ports the portgroup should contain}
	portgroup_type: ${6:earlyBinding|lateBinding|ephemeral}
	switch_name: ${7:# The name of the distributed vSwitch the port group should be created on.}
	vlan_id: ${8:# The VLAN ID that should be configured with the portgroup}

	validate_certs: ${9:#True|False}

endsnippet

snippet vmware_vsan_cluster "Configure VSAN clustering on an ESXi host" b
vmware_vsan_cluster:
	username: ${1:# The username of the vSphere vCenter.}
	password: ${2:# The password of the vSphere vCenter.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}

	cluster_uuid: ${4:# Desired cluster UUID}
	validate_certs: ${5:#True|False}

endsnippet

snippet vmware_dvswitch "Create or remove a distributed vSwitch" b
vmware_dvswitch:
	username: ${1:# The username of the vSphere vCenter.}
	password: ${2:# The password of the vSphere vCenter.}
	datacenter_name: ${3:# The name of the datacenter that will contain the dvSwitch}
	hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
	discovery_proto: ${5:cdp|lldp}
	mtu: ${6:# The switch maximum transmission unit}
	switch_name: ${7:# The name of the switch to create or remove}
	uplink_quantity: ${8:# Quantity of uplink per ESXi host added to the switch}

	state: ${9:#present|absent}
	discovery_operation: ${10:both|none|advertise|listen}
	validate_certs: ${11:#True|False}

endsnippet

snippet vmware_host "Add/remove ESXi host to/from vCenter" b
vmware_host:
	cluster_name: ${1:# Name of the cluster to add the host}
	username: ${2:# The username of the vSphere vCenter.}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	datacenter_name: ${4:# Name of the datacenter to add the host}
	esxi_hostname: ${5:# ESXi hostname to manage}
	esxi_password: ${6:# ESXi password}
	password: ${7:# The password of the vSphere vCenter.}
	esxi_username: ${8:# ESXi username}

	state: ${9:#present|absent}
	validate_certs: ${10:#True|False}

endsnippet

snippet vmware_portgroup "Create a VMware portgroup" b
vmware_portgroup:
	username: ${1:# The username of the vSphere vCenter.}
	portgroup_name: ${2:# Portgroup name to add}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	password: ${4:# The password of the vSphere vCenter.}
	switch_name: ${5:# vSwitch to modify}
	vlan_id: ${6:# VLAN ID to assign to portgroup}

	network_policy: ${7:# Network policy specifies layer 2 security settings for a portgroup such as promiscuous mode, where guest adapter listens to all the packets, MAC address changes and forged transmits. Settings are promiscuous_mode, forged_transmits, mac_changes}
	validate_certs: ${8:#True|False}

endsnippet

snippet vmware_maintenancemode "Place a host into maintenance mode" b
vmware_maintenancemode:
	username: ${1:# The username of the vSphere vCenter.}
	hostname: ${2:# The hostname or IP address of the vSphere vCenter.}
	esxi_hostname: ${3:# Name of the host as defined in vCenter}
	password: ${4:# The password of the vSphere vCenter.}

	timeout: ${5:0}
	evacuate: ${6:True|#False}
	vsan_mode: ${7:ensureObjectAccessibility|evacuateAllData|noAction}
	state: ${8:#present|absent}
	validate_certs: ${9:#True|False}

endsnippet

snippet vmware_vmkernel "Create a VMware VMkernel Interface" b
vmware_vmkernel:
	username: ${1:# The username of the vSphere vCenter.}
	portgroup_name: ${2:# The name of the portgroup for the VMK interface}
	vland_id: ${3:# The VLAN ID for the VMK interface}
	subnet_mask: ${4:# The Subnet Mask for the VMK interface}
	vswitch_name: ${5:# The name of the vswitch where to add the VMK interface}
	hostname: ${6:# The hostname or IP address of the vSphere vCenter.}
	password: ${7:# The password of the vSphere vCenter.}
	ip_address: ${8:# The IP Address for the VMK interface}

	enable_vmotion: ${9:# Enable the VMK interface for vMotion traffic}
	validate_certs: ${10:#True|False}
	mtu: ${11:# The MTU for the VMK interface}
	enable_mgmt: ${12:# Enable the VMK interface for Management traffic}
	enable_vsan: ${13:# Enable the VMK interface for VSAN traffic}
	enable_ft: ${14:# Enable the VMK interface for Fault Tolerance traffic}

endsnippet

snippet vmware_guest_snapshot "Manages virtual machines snapshots in vcenter" b
vmware_guest_snapshot:
	username: ${1:# The username of the vSphere vCenter.}
	datacenter: ${2:# Destination datacenter for the deploy operation}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	name: ${4:# Name of the VM to work with}
	state: ${5:present|absent|revert|remove_all}
	password: ${6:# The password of the vSphere vCenter.}

	uuid: ${7:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	snapshot_name: ${8:# Sets the snapshot name to manage.}
	name_match: ${9:#first|last}
	folder: ${10:# Define instance folder location.}
	validate_certs: ${11:#True|False}
	description: ${12:# Define an arbitrary description to attach to snapshot.}

endsnippet

snippet vmware_guest "Manages virtual machines in vcenter" b
vmware_guest:
	username: ${1:# The username of the vSphere vCenter.}
	name: ${2:# Name of the VM to work with}
	password: ${3:# The password of the vSphere vCenter.}
	hostname: ${4:# The hostname or IP address of the vSphere vCenter.}
	state: ${5:present|absent|poweredon|poweredoff|restarted|suspended|shutdownguest|rebootguest}

	resource_pool: ${6:# Affect machine to the given resource pool}
	force: ${7:# Ignore warnings and complete the actions}
	template: ${8:# Template used to create VM.}
	guest_id: ${9:# Set the guest ID (Debian, RHEL, Windows...)}
	cluster: ${10:# The cluster name where the VM will run.}
	hardware: ${11:# Manage some VM hardware attributes.}
	name_match: ${12:#first|last}
	customization: ${13:# Parameters to customize template}
	disk: ${14:# A list of disks to add}
	networks: ${15:# Network to use should include C(name) or C(vlan) entry}
	wait_for_ip_address: ${16:no}
	datacenter: ${17:ha-datacenter}
	uuid: ${18:# UUID of the instance to manage if known, this is VMware's unique identifier.}
	customvalues: ${19:# Define a list of customvalues to set on VM.}
	annotation: ${20:# A note or annotation to include in the VM}
	is_template: ${21:no}
	esxi_hostname: ${22:# The esxi hostname where the VM will run.}
	folder: ${23:# Destination folder, absolute path to find an existing guest or create the new guest}
	validate_certs: ${24:#True|False}

endsnippet

snippet vmware_vmkernel_ip_config "Configure the VMkernel IP Address" b
vmware_vmkernel_ip_config:
	username: ${1:# The username of the vSphere vCenter.}
	subnet_mask: ${2:# Subnet Mask to assign to VMkernel interface}
	hostname: ${3:# The hostname or IP address of the vSphere vCenter.}
	vmk_name: ${4:# VMkernel interface name}
	password: ${5:# The password of the vSphere vCenter.}
	ip_address: ${6:# IP address to assign to VMkernel interface}

	validate_certs: ${7:#True|False}

endsnippet

snippet jira "create and modify issues in a JIRA instance" b
jira:
	username: ${1:# The username to log-in with.}
	operation: ${2:create|comment|edit|fetch|transition}
	password: ${3:# The password to log-in with.}
	uri: ${4:# Base URI for the JIRA instance.}

	comment: ${5:# The comment text to add.}
	description: ${6:# The issue description, where appropriate.}
	assignee: ${7:# Sets the assignee on create or transition operations. Note not all transitions will allow this.}
	inwardissue: ${8:# Set issue from which link will be created.}
	linktype: ${9:# Set type of link, when action 'link' selected.}
	fields: ${10:# This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields.}
	outwardissue: ${11:# Set issue to which link will be created.}
	summary: ${12:# The issue summary, where appropriate.}
	project: ${13:# The project for this operation. Required for issue creation.}
	status: ${14:# The desired status; only relevant for the transition operation.}
	timeout: ${15:10}
	issuetype: ${16:# The issue type, for issue creation.}
	issue: ${17:# An existing issue key to operate on.}

endsnippet

snippet jenkins_script "Executes a groovy script in the jenkins instance" b
jenkins_script:
	script: ${1:# The groovy script to be executed. This gets passed as a string Template if args is defined.}

	password: ${2:# The password to connect to the jenkins server with.}
	user: ${3:# The username to connect to the jenkins server with.}
	url: ${4:http://localhost:8080}
	args: ${5:# A dict of key-value pairs used in formatting the script.}
	validate_certs: ${6:yes}

endsnippet

snippet jenkins_job "Manage jenkins jobs" b
jenkins_job:
	name: ${1:# Name of the Jenkins job.}

	url: ${2:http://localhost:8080}
	enabled: ${3:# Whether the job should be enabled or disabled.}
	state: ${4:#present|absent}
	token: ${5:# API token used to authenticate alternatively to password.}
	user: ${6:# User to authenticate with the Jenkins server.}
	password: ${7:# Password to authenticate with the Jenkins server.}
	config: ${8:# config in XML format.}

endsnippet

snippet mysql_variables "Manage MySQL global variables" b
mysql_variables:
	variable: ${1:# Variable name to operate}

	login_port: ${2:3306}
	ssl_cert: ${3:# The path to a client public key certificate.}
	config_file: ${4:~/.my.cnf}
	ssl_key: ${5:# The path to the client private key.}
	login_user: ${6:# The username used to authenticate with.}
	login_host: ${7:localhost}
	value: ${8:# If set, then sets variable value to this}
	ssl_ca: ${9:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	login_unix_socket: ${10:# The path to a Unix domain socket for local connections.}
	login_password: ${11:# The password used to authenticate with.}
	connect_timeout: ${12:30}

endsnippet

snippet mysql_replication "Manage MySQL replication" b
mysql_replication:
	master_ssl_cert: ${1:# same as mysql variable}
	master_auto_position: ${2:# does the host uses GTID based replication or not}
	config_file: ${3:~/.my.cnf}
	master_password: ${4:# same as mysql variable}
	master_host: ${5:# same as mysql variable}
	login_host: ${6:localhost}
	login_password: ${7:# The password used to authenticate with.}
	master_ssl_capath: ${8:# same as mysql variable}
	master_ssl_ca: ${9:# same as mysql variable}
	login_unix_socket: ${10:# The path to a Unix domain socket for local connections.}
	master_connect_retry: ${11:# same as mysql variable}
	master_user: ${12:# same as mysql variable}
	master_port: ${13:# same as mysql variable}
	master_log_file: ${14:# same as mysql variable}
	master_ssl_cipher: ${15:# same as mysql variable}
	relay_log_file: ${16:# same as mysql variable}
	login_port: ${17:3306}
	ssl_cert: ${18:# The path to a client public key certificate.}
	master_ssl: ${19:0|1}
	ssl_key: ${20:# The path to the client private key.}
	ssl_ca: ${21:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	master_ssl_key: ${22:# same as mysql variable}
	mode: ${23:#getslave|getmaster|changemaster|stopslave|startslave|resetslave|resetslaveall}
	login_user: ${24:# The username used to authenticate with.}
	master_log_pos: ${25:# same as mysql variable}
	connect_timeout: ${26:30}
	relay_log_pos: ${27:# same as mysql variable}

endsnippet

snippet mysql_user "Adds or removes a user from a MySQL database." b
mysql_user:
	name: ${1:# name of the user (role) to add or remove}

	login_port: ${2:3306}
	update_password: ${3:#always|on_create}
	ssl_cert: ${4:# The path to a client public key certificate.}
	config_file: ${5:~/.my.cnf}
	ssl_key: ${6:# The path to the client private key.}
	encrypted: ${7:yes|#no}
	login_host: ${8:localhost}
	append_privs: ${9:yes|#no}
	sql_log_bin: ${10:#yes|no}
	host_all: ${11:yes|#no}
	ssl_ca: ${12:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	login_password: ${13:# The password used to authenticate with.}
	login_unix_socket: ${14:# The path to a Unix domain socket for local connections.}
	state: ${15:#present|absent}
	login_user: ${16:# The username used to authenticate with.}
	host: ${17:localhost}
	check_implicit_admin: ${18:yes|#no}
	password: ${19:# set the user's password.}
	connect_timeout: ${20:30}
	priv: ${21:# MySQL privileges string in the format: C(db.table:priv1,priv2).}

endsnippet

snippet mysql_db "Add or remove MySQL databases from a remote host." b
mysql_db:
	name: ${1:# name of the database to add or remove}

	ssl_key: ${2:# The path to the client private key.}
	config_file: ${3:~/.my.cnf}
	encoding: ${4:# Encoding mode to use, examples include C(utf8) or C(latin1_swedish_ci)}
	login_user: ${5:# The username used to authenticate with.}
	login_host: ${6:localhost}
	login_unix_socket: ${7:# The path to a Unix domain socket for local connections.}
	login_password: ${8:# The password used to authenticate with.}
	collation: ${9:# Collation mode (sorting). This only applies to new table/databases and does not update existing ones, this is a limitation of MySQL.}
	ssl_ca: ${10:# The path to a Certificate Authority (CA) certificate. This option, if used, must specify the same certificate as used by the server.}
	single_transaction: ${11:no}
	login_port: ${12:3306}
	ssl_cert: ${13:# The path to a client public key certificate.}
	target: ${14:# Location, on the remote host, of the dump file to read from or write to. Uncompressed SQL files (C(.sql)) as well as bzip2 (C(.bz2)), gzip (C(.gz)) and xz (Added in 2.0) compressed files are supported.}
	state: ${15:#present|absent|dump|import}
	quick: ${16:yes}
	connect_timeout: ${17:30}

endsnippet

snippet postgresql_db "Add or remove PostgreSQL databases from a remote host." b
postgresql_db:
	name: ${1:# name of the database to add or remove}

	ssl_rootcert: ${2:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s).}
	ssl_mode: ${3:disable|allow|#prefer|require|verify-ca|verify-full}
	encoding: ${4:# Encoding of the database}
	login_user: ${5:postgres}
	lc_collate: ${6:# Collation order (LC_COLLATE) to use in the database. Must match collation order of template database unless C(template0) is used as template.}
	lc_ctype: ${7:# Character classification (LC_CTYPE) to use in the database (e.g. lower, upper, ...) Must match LC_CTYPE of template database unless C(template0) is used as template.}
	port: ${8:5432}
	login_unix_socket: ${9:# Path to a Unix domain socket for local connections}
	state: ${10:#present|absent}
	template: ${11:# Template used to create the database}
	login_password: ${12:# The password used to authenticate with}
	owner: ${13:# Name of the role to set as owner of the database}
	login_host: ${14:# Host running the database}

endsnippet

snippet postgresql_lang "Adds, removes or changes procedural languages with a PostgreSQL database." b
postgresql_lang:
	lang: ${1:# name of the procedural language to add, remove or change}

	force_trust: ${2:yes|no}
	login_user: ${3:postgres}
	login_host: ${4:localhost}
	db: ${5:# name of database where the language will be added, removed or changed}
	cascade: ${6:yes|no}
	state: ${7:#present|absent}
	login_password: ${8:# Password used to authenticate with PostgreSQL (must match C(login_user))}
	trust: ${9:yes|no}
	fail_on_drop: ${10:#yes|no}
	port: ${11:5432}

endsnippet

snippet postgresql_user "Adds or removes a users (roles) from a PostgreSQL database." b
postgresql_user:
	name: ${1:# name of the user (role) to add or remove}

	ssl_rootcert: ${2:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.}
	ssl_mode: ${3:disable|allow|#prefer|require|verify-ca|verify-full}
	login_user: ${4:postgres}
	login_host: ${5:localhost}
	expires: ${6:# sets the user's password expiration.}
	db: ${7:# name of database where permissions will be granted}
	login_unix_socket: ${8:# Path to a Unix domain socket for local connections}
	login_password: ${9:# Password used to authenticate with PostgreSQL}
	password: ${10:# set the user's password, before 1.4 this was required.}
	port: ${11:5432}
	fail_on_user: ${12:#yes|no}
	priv: ${13:# PostgreSQL privileges string in the format: C(table:priv1,priv2)}
	no_password_changes: ${14:yes|#no}
	state: ${15:#present|absent}
	encrypted: ${16:no}
	role_attr_flags: ${17:[NO]SUPERUSER|[NO]CREATEROLE|[NO]CREATEUSER|[NO]CREATEDB|[NO]INHERIT|[NO]LOGIN|[NO]REPLICATION}

endsnippet

snippet postgresql_privs "Grant or revoke privileges on PostgreSQL database objects." b
postgresql_privs:
	roles: ${1:# Comma separated list of role (user/group) names to set permissions for.}
	database: ${2:# Name of database to connect to.}

	objs: ${3:# Comma separated list of database objects to set privileges on.}
	ssl_rootcert: ${4:# Specifies the name of a file containing SSL certificate authority (CA) certificate(s). If the file exists, the server's certificate will be verified to be signed by one of these authorities.}
	ssl_mode: ${5:disable|allow|#prefer|require|verify-ca|verify-full}
	privs: ${6:# Comma separated list of privileges to grant/revoke.}
	state: ${7:#present|absent}
	unix_socket: ${8:# Path to a Unix domain socket for local connections.}
	host: ${9:# Database host address. If unspecified, connect via Unix socket.}
	login: ${10:postgres}
	password: ${11:# The password to authenticate with.}
	type: ${12:#table|sequence|function|database|schema|language|tablespace|group}
	port: ${13:5432}
	grant_option: ${14:yes|no}
	schema: ${15:# Schema that contains the database objects specified via I(objs).}

endsnippet

snippet postgresql_ext "Add or remove PostgreSQL extensions from a database." b
postgresql_ext:
	name: ${1:# name of the extension to add or remove}
	db: ${2:# name of the database to add or remove the extension to/from}

	state: ${3:#present|absent}
	login_password: ${4:# The password used to authenticate with}
	login_user: ${5:# The username used to authenticate with}
	login_host: ${6:localhost}
	port: ${7:5432}

endsnippet

snippet postgresql_schema "Add or remove PostgreSQL schema from a remote host" b
postgresql_schema:
	name: ${1:# Name of the schema to add or remove.}

	database: ${2:postgres}
	login_user: ${3:# The username used to authenticate with.}
	login_host: ${4:localhost}
	login_unix_socket: ${5:# Path to a Unix domain socket for local connections.}
	state: ${6:#present|absent}
	login_password: ${7:# The password used to authenticate with.}
	owner: ${8:# Name of the role to set as owner of the schema.}
	port: ${9:5432}

endsnippet

snippet meta "Execute Ansible 'actions'" b
meta:
	${1:free_form: noop|flush_handlers|refresh_inventory|clear_facts|clear_host_errors|end_play}

endsnippet

snippet pause "Pause playbook execution" b
pause:
	seconds: ${1:# A positive number of seconds to pause for.}
	minutes: ${2:# A positive number of minutes to pause for.}
	prompt: ${3:# Optional text to use for the prompt message.}

endsnippet

snippet debug "Print statements during execution" b
- name: ${1:Debugging}
  debug:
    msg: ${2:Hello world!}
    var: ${3:# A variable name to debug.  Mutually exclusive with the 'msg' option.}

endsnippet

snippet include_vars "Load variables from files, dynamically within a task." b
- name: ${1}
	include_vars:
		file: ${2:# The file name from which variables should be loaded.}
endsnippet

snippet wait_for "Waits for a condition before continuing." b
wait_for:
	active_connection_states: ${1:[u'ESTABLISHED', u'SYN_SENT', u'SYN_RECV', u'FIN_WAIT1', u'FIN_WAIT2', u'TIME_WAIT']}
	host: ${2:127.0.0.1}
	connect_timeout: ${3:5}
	delay: ${4:0}
	state: ${5:present|#started|stopped|absent|drained}
	sleep: ${6:1}
	timeout: ${7:300}
	exclude_hosts: ${8:# list of hosts or IPs to ignore when looking for active TCP connections for C(drained) state}
	search_regex: ${9:# Can be used to match a string in either a file or a socket connection. Defaults to a multiline regex.}
	path: ${10:# path to a file on the filesytem that must exist before continuing}
	port: ${11:# port number to poll}

endsnippet

snippet assert "Asserts given expressions are true" b
assert:
	that: ${1:# A string expression of the same form that can be passed to the 'when' statement}

	msg: ${2:# The customized message used for a failing assertion}

endsnippet

snippet async_status "Obtain status of asynchronous task" b
async_status:
	jid: ${1:# Job or task identifier}

	mode: ${2:#status|cleanup}

endsnippet

snippet set_stats "Set stats for the current ansible run" b
set_stats:
	data: ${1:# A dictionary of which each key represents a stat (or variable) you want to keep track of}

	aggregate: ${2:yes}
	per_host: ${3:no}

endsnippet

snippet include "include a play or task list." b
include:
	free-form: ${1:# This module allows you to specify the name of the file directly w/o any other options.}

endsnippet

snippet include_role "Load and execute a role" b
include_role:
	name: ${1:# The name of the role to be executed.}

	allow_duplicates: ${2:yes}
	tasks_from: ${3:main}
	vars_from: ${4:main}
	defaults_from: ${5:main}
	private: ${6:# If True the variables from defaults/ and vars/ in a role will not be made available to the rest of the play.}

endsnippet

snippet fail "Fail with custom message" b
fail:
	msg: ${1:'Failed as requested from task'}

endsnippet

snippet wait_for_connection "Waits until remote system is reachable/usable" b
wait_for_connection:
	delay: ${1:0}
	sleep: ${2:1}
	connect_timeout: ${3:5}
	timeout: ${4:600}

endsnippet

snippet set_fact "Set host facts from a task" b
set_fact:
	key_value: ${1:# The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement.}

endsnippet

snippet hipchat "Send a message to Hipchat." b
hipchat:
	room: ${1:# ID or name of the room.}
	token: ${2:# API token.}
	msg: ${3:# The message body.}

	from: ${4:Ansible}
	color: ${5:#yellow|red|green|purple|gray|random}
	msg_format: ${6:#text|html}
	api: ${7:https://api.hipchat.com/v1}
	notify: ${8:#yes|no}
	validate_certs: ${9:#yes|no}

endsnippet

snippet rhn_channel "Adds or removes Red Hat software channels" b
rhn_channel:
	sysname: ${1:# name of the system as it is known in RHN/Satellite}
	name: ${2:# name of the software channel}
	url: ${3:# The full url to the RHN/Satellite api}
	password: ${4:# the user's password}
	user: ${5:# RHN/Satellite user}

	state: ${6:present}

endsnippet

snippet pacman "Manage packages with I(pacman)" b
pacman:
	state: ${1:#present|absent|latest}
	upgrade: ${2:yes|no}
	force: ${3:yes|no}
	name: ${4:# Name of the package to install, upgrade, or remove.}
	update_cache: ${5:yes|no}
	recurse: ${6:yes|no}

endsnippet

snippet dpkg_selections "Dpkg package selection selections" b
dpkg_selections:
	selection: ${1:install|hold|deinstall|purge}
	name: ${2:# Name of the package}

endsnippet

snippet apt "Manages apt-packages" b
apt:
	dpkg_options: ${1:force-confdef,force-confold}
	upgrade: ${2:#no|yes|safe|full|dist}
	force: ${3:yes|#no}
	name: ${4:# A package name, like C(foo), or package specifier with version, like C(foo=1.0). Name wildcards (fnmatch) like C(apt*) and version wildcards like C(foo=1.0*) are also supported.  Note that the apt-get commandline supports implicit regex matches here but we do not because it can let typos through easier (If you typo C(foo) as C(fo) apt-get would install packages that have "fo" in their name with a warning and a prompt for the user.  Since we don't have warnings and prompts before installing we disallow this.  Use an explicit fnmatch pattern if you want wildcarding)}
	purge: ${5:yes|no}
	allow_unauthenticated: ${6:yes|#no}
	state: ${7:latest|absent|#present|build-dep}
	autoremove: ${8:yes|no}
	update_cache: ${9:yes|no}
	default_release: ${10:# Corresponds to the C(-t) option for I(apt) and sets pin priorities}
	only_upgrade: ${11:no}
	cache_valid_time: ${12:0}
	deb: ${13:# Path to a .deb package on the remote machine.}
	install_recommends: ${14:yes|no}

endsnippet

snippet homebrew_cask "Install/uninstall homebrew casks." b
homebrew_cask:
	name: ${1:# name of cask to install/remove}

	update_homebrew: ${2:yes|no}
	path: ${3:/usr/local/bin}
	state: ${4:#present|absent}
	install_options: ${5:# options flags to install a package}

endsnippet

snippet homebrew_tap "Tap a Homebrew repository." b
homebrew_tap:
	name: ${1:# The GitHub user/organization repository to tap.}

	url: ${2:# The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.}
	state: ${3:#present|absent}

endsnippet

snippet yum "Manages packages with the I(yum) package manager" b
yum:
	name: ${1:# Package name, or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: yum -y update. You can also pass a url or a local path to a rpm file (using state=present).  To operate on several packages this can accept a comma separated list of packages or (as of 2.0) a list of packages.}

	exclude: ${2:# Package name(s) to exclude when state=present, or latest}
	list: ${3:# Package name to run the equivalent of yum list <package> against.}
	disable_gpg_check: ${4:yes|#no}
	conf_file: ${5:# The remote yum configuration file to use for the transaction.}
	state: ${6:#present|installed|latest|absent|removed}
	disablerepo: ${7:# I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
	update_cache: ${8:yes|#no}
	enablerepo: ${9:# I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".}
	skip_broken: ${10:yes|#no}
	validate_certs: ${11:#yes|no}
	installroot: ${12:/}

endsnippet

snippet package "Generic OS package manager" b
package:
	state: ${1:# Whether to install (C(present), C(latest)), or remove (C(absent)) a package.}
	name: ${2:# Package name, or package specifier with version, like C(name-1.0).}

	use: ${3:auto}

endsnippet

snippet rpm_key "Adds or removes a gpg key from the rpm db" b
rpm_key:
	key: ${1:# Key that will be modified. Can be a url, a file, or a keyid if the key already exists in the database.}

	state: ${2:#present|absent}
	validate_certs: ${3:#yes|no}

endsnippet

snippet redhat_subscription "Manage registration and subscriptions to RHSM using the C(subscription-manager) command" b
redhat_subscription:
	username: ${1:# access.redhat.com or Sat6  username}
	server_hostname: ${2:Current value from C(/etc/rhsm/rhsm.conf) is the default}
	password: ${3:# access.redhat.com or Sat6 password}
	consumer_type: ${4:# The type of unit to register, defaults to system}
	org_id: ${5:# Organization ID to use in conjunction with activationkey}
	consumer_id: ${6:# References an existing consumer ID to resume using a previous registration
for this system. If the  system's identity certificate is lost or corrupted,
this option allows it to resume using its previous identity and subscriptions.
The default is to not specify a consumer ID so a new ID is created.
}
	environment: ${7:# Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello}
	force_register: ${8:no}
	state: ${9:#present|absent}
	autosubscribe: ${10:no}
	activationkey: ${11:# supply an activation key for use with registration}
	server_insecure: ${12:Current value from C(/etc/rhsm/rhsm.conf) is the default}
	consumer_name: ${13:# Name of the system to register, defaults to the hostname}
	rhsm_baseurl: ${14:Current value from C(/etc/rhsm/rhsm.conf) is the default}
	pool: ${15:^$}

endsnippet

snippet apk "Manages apk packages" b
apk:
	state: ${1:#present|absent|latest}
	upgrade: ${2:yes|no}
	update_cache: ${3:yes|no}
	name: ${4:# A package name, like C(foo), or mutliple packages, like C(foo, bar).}

endsnippet

snippet apt_repository "Add and remove APT repositories" b
apt_repository:
	repo: ${1:none}

	state: ${2:absent|#present}
	update_cache: ${3:#yes|no}
	mode: ${4:420}
	codename: ${5:# Override the distribution codename to use for PPA repositories. Should usually only be set when working with a PPA on a non-Ubuntu target (e.g. Debian or Mint)}
	validate_certs: ${6:#yes|no}
	filename: ${7:# Sets the name of the source list file in sources.list.d. Defaults to a file name based on the repository source url. The .list extension will be automatically added.}

endsnippet

snippet homebrew "Package manager for Homebrew" b
homebrew:
	install_options: ${1:# options flags to install a package}
	state: ${2:head|latest|#present|absent|linked|unlinked}
	name: ${3:# name of package to install/remove}
	update_homebrew: ${4:yes|no}
	path: ${5:/usr/local/bin}
	upgrade_all: ${6:yes|no}

endsnippet

snippet apt_key "Add or remove an apt key" b
apt_key:
	keyserver: ${1:none}
	url: ${2:none}
	data: ${3:none}
	keyring: ${4:none}
	state: ${5:absent|#present}
	file: ${6:none}
	validate_certs: ${7:#yes|no}
	id: ${8:none}

endsnippet

snippet yum_repository "Add or remove YUM repositories" b
yum_repository:
	name: ${1:# Unique repository ID.}

	seuser: ${2:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	ip_resolve: ${3:4|6|IPv4|IPv6|#whatever}
	enabled: ${4:#yes|no}
	proxy_password: ${5:# Username to use for proxy.}
	mode: ${6:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	owner: ${7:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	bandwidth: ${8:0}
	cost: ${9:1000}
	file: ${10:# File to use to save the repo in. Defaults to the value of I(name).}
	mirrorlist_expire: ${11:21600}
	exclude: ${12:# List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.}
	attributes: ${13:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	keepalive: ${14:yes|#no}
	repo_gpgcheck: ${15:yes|#no}
	sslverify: ${16:#yes|no}
	failovermethod: ${17:#roundrobin|priority}
	unsafe_writes: ${18:no}
	deltarpm_metadata_percentage: ${19:100}
	gpgkey: ${20:# A URL pointing to the ASCII-armored GPG key file for the repository.}
	serole: ${21:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	http_caching: ${22:#all|packages|none}
	priority: ${23:99}
	state: ${24:absent|#present}
	mirrorlist: ${25:# Specifies a URL to a file containing a list of baseurls.}
	params: ${26:# Option used to allow the user to overwrite any of the other options. To remove an option, set the value of the option to C(null).}
	setype: ${27:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
	gpgcheck: ${28:yes|#no}
	include: ${29:# Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected.}
	proxy_username: ${30:# Password for this proxy.}
	username: ${31:# Username to use for basic authentication to a repo or really any url.}
	metadata_expire: ${32:21600}
	description: ${33:# A human readable string describing the repository.}
	retries: ${34:10}
	selevel: ${35:s0}
	sslclientcert: ${36:# Path to the SSL client certificate yum should use to connect to repos/remote sites.}
	baseurl: ${37:# URL to the directory where the yum repository's 'repodata' directory lives.}
	gpgcakey: ${38:# A URL pointing to the ASCII-armored CA key file for the repository.}
	s3_enabled: ${39:yes|#no}
	includepkgs: ${40:# List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.}
	enablegroups: ${41:#yes|no}
	group: ${42:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	password: ${43:# Password to use with the username for basic authentication.}
	ui_repoid_vars: ${44:releasever basearch}
	protect: ${45:yes|#no}
	ssl_check_cert_permissions: ${46:yes|#no}
	throttle: ${47:# Enable bandwidth throttling for downloads.}
	deltarpm_percentage: ${48:75}
	sslclientkey: ${49:# Path to the SSL client key yum should use to connect to repos/remote sites.}
	metalink: ${50:# Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).}
	reposdir: ${51:/etc/yum.repos.d}
	skip_if_unavailable: ${52:yes|#no}
	keepcache: ${53:0|#1}
	sslcacert: ${54:# Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates.}
	timeout: ${55:30}
	async: ${56:#yes|no}
	metadata_expire_filter: ${57:never|read-only:past|#read-only:present|read-only:future}
	proxy: ${58:# URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting.}

endsnippet

snippet rhn_register "Manage Red Hat Network registration using the C(rhnreg_ks) command" b
rhn_register:
	username: ${1:# Red Hat Network username}
	systemorgid: ${2:# supply an organizational id for use with registration}
	enable_eus: ${3:no}
	server_url: ${4:Current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date) is the default}
	channels: ${5:[]}
	state: ${6:#present|absent}
	sslcacert: ${7:# supply a custom ssl CA certificate file for use with registration}
	activationkey: ${8:# supply an activation key for use with registration}
	profilename: ${9:# supply an profilename for use with registration}
	password: ${10:# Red Hat Network password}

endsnippet

snippet filesystem "Makes file system on block device" b
filesystem:
	dev: ${1:# Target block device.}
	fstype: ${2:# File System type to be created.}

	resizefs: ${3:yes|#no}
	force: ${4:yes|#no}
	opts: ${5:# List of options to be passed to mkfs command.}

endsnippet

snippet authorized_key "Adds or removes an SSH authorized key" b
authorized_key:
	user: ${1:# The username on the remote host whose authorized_keys file will be modified}
	key: ${2:# The SSH public key(s), as a string or (since 1.9) url (https://github.com/username.keys)}

	exclusive: ${3:yes|#no}
	key_options: ${4:# A string of ssh key options to be prepended to the key in the authorized_keys file}
	state: ${5:#present|absent}
	path: ${6:(homedir)+/.ssh/authorized_keys}
	validate_certs: ${7:#yes|no}
	manage_dir: ${8:#yes|no}

endsnippet

snippet service "Manage services." b
service:
	name: ${1:# Name of the service.}

	use: ${2:auto}
	pattern: ${3:# If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.  If the string is found, the service will be assumed to be running.}
	enabled: ${4:yes|no}
	state: ${5:started|stopped|restarted|reloaded}
	sleep: ${6:# If the service is being C(restarted) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving init scripts that exit immediately after signaling a process to stop.}
	arguments: ${7:# Additional arguments provided on the command line}
	runlevel: ${8:default}

endsnippet

snippet group "Add or remove groups" b
group:
	name: ${1:# Name of the group to manage.}

	state: ${2:#present|absent}
	gid: ${3:# Optional I(GID) to set for the group.}
	system: ${4:yes|#no}

endsnippet

snippet mount "Control active and configured mount points" b
mount:
	state: ${1:present|absent|mounted|unmounted}
	path: ${2:# Path to the mount point (e.g. C(/mnt/files)).}

	src: ${3:# Device to be mounted on I(path). Required when I(state) set to C(present) or C(mounted).}
	dump: ${4:0}
	passno: ${5:0}
	fstab: ${6:/etc/fstab (/etc/vfstab on Solaris)}
	boot: ${7:yes|no}
	fstype: ${8:# Filesystem type. Required when I(state) is C(present) or C(mounted).}
	opts: ${9:# Mount options (see fstab(5), or vfstab(4) on Solaris).}

endsnippet

snippet user "Manage user accounts" b
user:
	name: ${1:# Name of the user to create, remove or modify.}

	comment: ${2:# Optionally sets the description (aka I(GECOS)) of user account.}
	ssh_key_bits: ${3:default set by ssh-keygen}
	update_password: ${4:#always|on_create}
	non_unique: ${5:yes|#no}
	force: ${6:yes|#no}
	ssh_key_type: ${7:rsa}
	expires: ${8:# An expiry time for the user in epoch, it will be ignored on platforms that do not support this. Currently supported on Linux and FreeBSD.}
	ssh_key_passphrase: ${9:# Set a passphrase for the SSH key.  If no passphrase is provided, the SSH key will default to having no passphrase.}
	groups: ${10:# Puts the user in  list of groups. When set to the empty string ('groups='), the user is removed from all groups except the primary group.}
	home: ${11:# Optionally set the user's home directory.}
	move_home: ${12:yes|#no}
	password: ${13:# Optionally set the user's password to this crypted value.  See the user example in the github examples directory for what this looks like in a playbook. See U(http://docs.ansible.com/ansible/faq.html#how-do-i-generate-crypted-passwords-for-the-user-module) for details on various ways to generate these password values. Note on Darwin system, this value has to be cleartext. Beware of security issues.}
	skeleton: ${14:# Optionally set a home skeleton directory. Requires createhome option!}
	generate_ssh_key: ${15:yes|#no}
	append: ${16:yes|#no}
	uid: ${17:# Optionally sets the I(UID) of the user.}
	ssh_key_comment: ${18:ansible-generated on $HOSTNAME}
	group: ${19:# Optionally sets the user's primary group (takes a group name).}
	createhome: ${20:#yes|no}
	system: ${21:yes|#no}
	remove: ${22:yes|#no}
	seuser: ${23:# Optionally sets the seuser type (user_u) on selinux enabled systems.}
	state: ${24:#present|absent}
	ssh_key_file: ${25:.ssh/id_rsa}
	login_class: ${26:# Optionally sets the user's login class for FreeBSD, OpenBSD and NetBSD systems.}
	shell: ${27:# Optionally set the user's shell.}

endsnippet

snippet hostname "Manage hostname" b
hostname:
	name: ${1:# Name of the host}

endsnippet

snippet firewalld "Manage arbitrary ports/services with firewalld" b
firewalld:
	state: ${1:enabled|disabled}

	zone: ${2:work|drop|internal|external|trusted|home|dmz|public|block}
	service: ${3:# Name of a service to add/remove to/from firewalld - service must be listed in output of firewall-cmd --get-services.}
	masquerade: ${4:# The masquerade setting you would like to enable/disable to/from zones within firewalld}
	immediate: ${5:no}
	source: ${6:# The source/network you would like to add/remove to/from firewalld}
	permanent: ${7:# Should this configuration be in the running firewalld configuration or persist across reboots. As of Ansible version 2.3, permanent operations can operate on firewalld configs when it's not running (requires firewalld >= 3.0.9)}
	timeout: ${8:0}
	interface: ${9:# The interface you would like to add/remove to/from a zone in firewalld}
	port: ${10:# Name of a port or port range to add/remove to/from firewalld. Must be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges.}
	rich_rule: ${11:# Rich rule to add/remove to/from firewalld.}

endsnippet

snippet ufw "Manage firewall with UFW" b
ufw:
	direction: ${1:in|out|incoming|outgoing|routed}
	from_port: ${2:# Source port.}
	to_ip: ${3:any}
	to_port: ${4:# Destination port.}
	from_ip: ${5:any}
	interface: ${6:# Specify interface for rule.}
	name: ${7:# Use profile located in C(/etc/ufw/applications.d)}
	insert: ${8:# Insert the corresponding rule as rule number NUM}
	logging: ${9:on|off|low|medium|high|full}
	log: ${10:yes|no}
	proto: ${11:any|tcp|udp|ipv6|esp|ah}
	route: ${12:yes|no}
	rule: ${13:allow|deny|reject|limit}
	state: ${14:enabled|disabled|reloaded|reset}
	policy: ${15:allow|deny|reject}
	delete: ${16:yes|no}

endsnippet

snippet cron "Manage cron.d and crontab entries." b
cron:
	cron_file: ${1:# If specified, uses this file instead of an individual user's crontab. If this is a relative path, it is interpreted with respect to /etc/cron.d. (If it is absolute, it will typically be /etc/crontab). To use the C(cron_file) parameter you must specify the C(user) as well.}
	month: ${2:*}
	disabled: ${3:no}
	job: ${4:# The command to execute or, if env is set, the value of environment variable. Required if state=present.}
	special_time: ${5:reboot|yearly|annually|monthly|weekly|daily|hourly}
	user: ${6:root}
	insertafter: ${7:# Used with C(state=present) and C(env). If specified, the environment variable will be inserted after the declaration of specified environment variable.}
	insertbefore: ${8:# Used with C(state=present) and C(env). If specified, the environment variable will be inserted before the declaration of specified environment variable.}
	day: ${9:*}
	minute: ${10:*}
	name: ${11:# Description of a crontab entry or, if env is set, the name of environment variable. Required if state=absent. Note that if name is not set and state=present, then a new crontab entry will always be created, regardless of existing ones.}
	hour: ${12:*}
	reboot: ${13:yes|#no}
	state: ${14:#present|absent}
	weekday: ${15:*}
	env: ${16:yes|#no}
	backup: ${17:yes|no}

endsnippet

snippet selinux "Change policy and state of SELinux" b
selinux:
	state: ${1:enforcing|permissive|disabled}

	policy: ${2:# name of the SELinux policy to use (example: C(targeted)) will be required if state is not C(disabled)}
	conf: ${3:/etc/selinux/config}

endsnippet

snippet selinux_permissive "Change permissive domain in SELinux policy" b
selinux_permissive:
	domain: ${1:# the domain that will be added or removed from the list of permissive domains}
	permissive: ${2:True|False}

	no_reload: ${3:True|False}
	store: ${4:# name of the SELinux policy store to use}

endsnippet

snippet kernel_blacklist "Blacklist kernel modules" b
kernel_blacklist:
	name: ${1:# Name of kernel module to black- or whitelist.}

	blacklist_file: ${2:# If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf).}
	state: ${3:#present|absent}

endsnippet

snippet lvg "Configure LVM volume groups" b
lvg:
	vg: ${1:# The name of the volume group.}

	vg_options: ${2:# Additional options to pass to C(vgcreate) when creating the volume group.}
	pvs: ${3:# List of comma-separated devices to use as physical devices in this volume group. Required when creating or resizing volume group.}
	force: ${4:yes|#no}
	pesize: ${5:4}
	state: ${6:#present|absent}

endsnippet

snippet lvol "Configure LVM logical volumes" b
lvol:
	vg: ${1:# The volume group this logical volume is part of.}
	lv: ${2:# The name of the logical volume.}

	pvs: ${3:# Comma separated list of physical volumes e.g. /dev/sda,/dev/sdb}
	force: ${4:yes|#no}
	state: ${5:#present|absent}
	snapshot: ${6:# The name of the snapshot volume}
	active: ${7:#yes|no}
	shrink: ${8:yes}
	opts: ${9:# Free-form options to be passed to the lvcreate command}
	size: ${10:# The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1.}

endsnippet

snippet debconf "Configure a .deb package" b
debconf:
	name: ${1:# Name of package to configure.}

	value: ${2:# Value to set the configuration to}
	vtype: ${3:string|password|boolean|select|multiselect|note|error|title|text|seen}
	question: ${4:# A debconf configuration setting}
	unseen: ${5:no}

endsnippet

snippet parted "Configure block device partitions" b
parted:
	device: ${1:# T}

	part_start: ${2:0%}
	part_end: ${3:100%}
	name: ${4:# Sets the name for the partition number (GPT, Mac, MIPS and PC98 only).}
	align: ${5:none|cylinder|minimal|#optimal}
	number: ${6:# The number of the partition to work with or the number of the partition that will be created. Required when performing any action on the disk, except fetching information.}
	label: ${7:aix|amiga|bsd|dvh|gpt|loop|mac|#msdos|pc98|sun|}
	state: ${8:present|absent|#info}
	part_type: ${9:primary|extended|logical}
	flags: ${10:# A}
	unit: ${11:s|B|KB|#KiB|MB|MiB|GB|GiB|TB|TiB|%|cyl|chs|compact}

endsnippet

snippet systemd "Manage services." b
systemd:
	name: ${1:# Name of the service. When using in a chroot environment you always need to specify the full name i.e. (crond.service).}

	masked: ${2:yes|no}
	state: ${3:started|stopped|restarted|reloaded}
	no_block: ${4:yes|no}
	enabled: ${5:yes|no}
	daemon_reload: ${6:yes|no}
	user: ${7:yes|no}

endsnippet

snippet pamd "Manage PAM Modules" b
pamd:
	control: ${1:# The control of the PAM rule being modified.  This may be a complicated control with brackets.  If this is the case, be sure to put "[bracketed controls]" in quotes.  The type, control and module_path all must match a rule to be modified.}
	name: ${2:# The name generally refers to the PAM service file to change, for example system-auth.}
	module_path: ${3:# The module path of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}
	type: ${4:# The type of the PAM rule being modified.  The type, control and module_path all must match a rule to be modified.}

	new_module_path: ${5:# The control to assign to the new rule.}
	new_type: ${6:# The type to assign to the new rule.}
	state: ${7:#updated|before|after|args_present|args_absent}
	new_control: ${8:# The control to assign to the new rule.}
	path: ${9:/etc/pam.d/}
	module_arguments: ${10:# When state is 'updated', the module_arguments will replace existing module_arguments.  When state is 'args_absent' args matching those listed in module_arguments will be removed.  When state is 'args_present' any args listed in module_arguments are added if missing from the existing rule.  Furthermore, if the module argument takes a value denoted by '=', the value will be changed to that specified in module_arguments.}

endsnippet

snippet locale_gen "Creates or removes locales." b
locale_gen:
	name: ${1:# Name and encoding of the locale, such as "en_GB.UTF-8".}

	state: ${2:#present|absent}

endsnippet

snippet iptables "Modify the systems iptables" b
iptables:
	comment: ${1:# This specifies a comment that will be added to the rule}
	protocol: ${2:# The protocol of the rule or of the packet to check. The specified protocol can be one of tcp, udp, udplite, icmp, esp, ah, sctp or the special keyword "all", or it can be a numeric value, representing one of these protocols or a different one. A protocol name from /etc/protocols is also allowed. A "!" argument before the protocol inverts the test.  The number zero is equivalent to all. "all" will match with all protocols and is taken as default when this option is omitted.}
	goto: ${3:# This specifies that the processing should continue in a user specified chain. Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.}
	chain: ${4:# Chain to operate on. This option can either be the name of a user defined chain or any of the builtin chains: 'INPUT', 'FORWARD', 'OUTPUT', 'PREROUTING', 'POSTROUTING', 'SECMARK', 'CONNSECMARK'.}
	fragment: ${5:# This means that the rule only refers to second and further fragments of fragmented packets. Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them. When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.}
	out_interface: ${6:# Name of an interface via which a packet is going to be sent (for packets entering the FORWARD, OUTPUT and POSTROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.}
	to_source: ${7:# This specifies a source address to use with SNAT: without this, the source address is never altered.}
	limit_burst: ${8:# Specifies the maximum burst before the above limit kicks in.}
	ctstate: ${9:[]}
	jump: ${10:# This specifies the target of the rule; i.e., what to do if the packet matches it. The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).  If this option is omitted in a rule (and the goto paramater is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.}
	policy: ${11:# Set the policy for the chain to the given target. Valid targets are ACCEPT, DROP, QUEUE, RETURN. Only built in chains can have policies. This parameter requires the chain parameter. Ignores all other parameters.}
	source_port: ${12:# Source port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.}
	to_ports: ${13:# This specifies a destination port or range of ports to use: without this, the destination port is never altered. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.}
	flush: ${14:# Flushes the specified table and chain of all rules. If no chain is specified then the entire table is purged. Ignores all other parameters.}
	table: ${15:#filter|nat|mangle|raw|security}
	destination_port: ${16:# Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped.}
	icmp_type: ${17:# This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'}
	to_destination: ${18:# This specifies a destination address to use with DNAT: without this, the destination address is never altered.}
	in_interface: ${19:# Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and PREROUTING chains). When the "!" argument is used before the interface name, the sense is inverted. If the interface name ends in a "+", then any interface which begins with this name will match. If this option is omitted, any interface name will match.}
	uid_owner: ${20:# Specifies the UID or username to use in match by owner rule.}
	set_dscp_mark_class: ${21:# This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark. Mutually exclusive with C(set_dscp_mark).}
	destination: ${22:# Destination specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.}
	set_dscp_mark: ${23:# This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value. Mutually exclusive with C(set_dscp_mark_class).}
	reject_with: ${24:# Specifies the error packet type to return while rejecting.}
	source: ${25:# Source specification. Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address. Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea. The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A "!" argument before the address specification inverts the sense of the address.}
	state: ${26:#present|absent}
	limit: ${27:# Specifies the maximum average number of matches to allow per second. The number can specify units explicitly, using `/second', `/minute', `/hour' or `/day', or parts of them (so `5/second' is the same as `5/s').}
	action: ${28:#append|insert}
	set_counters: ${29:# This enables the administrator to initialize the packet and byte counters of a rule (during INSERT, APPEND, REPLACE operations).}
	ip_version: ${30:#ipv4|ipv6}
	match: ${31:[]}

endsnippet

snippet known_hosts "Add or remove a host from the C(known_hosts) file" b
known_hosts:
	name: ${1:# The host to add or remove (must match a host specified in key)}

	path: ${2:(homedir)+/.ssh/known_hosts}
	state: ${3:#present|absent}
	hash_host: ${4:no}
	key: ${5:# The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(1), section "SSH_KNOWN_HOSTS FILE FORMAT")}

endsnippet

snippet timezone "Configure timezone setting" b
timezone:
	hwclock: ${1:# Whether the hardware clock is in UTC or in local timezone. Default is to keep current setting. Note that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS. B(At least one of name and hwclock are required.) I(Only used on Linux.)}
	name: ${2:# Name of the timezone for the system clock. Default is to keep current setting. B(At least one of name and hwclock are required.)}

endsnippet

snippet modprobe "Add or remove kernel modules" b
modprobe:
	name: ${1:# Name of kernel module to manage.}

	state: ${2:#present|absent}
	params: ${3:}

endsnippet

snippet pam_limits "Modify Linux PAM limits" b
pam_limits:
	domain: ${1:# A username, @groupname, wildcard, uid/gid range.}
	value: ${2:# The value of the limit.}
	limit_item: ${3:core|data|fsize|memlock|nofile|rss|stack|cpu|nproc|as|maxlogins|maxsyslogins|priority|locks|sigpending|msgqueue|nice|rtprio|chroot}
	limit_type: ${4:hard|soft|-}

	comment: ${5:}
	use_max: ${6:yes|#no}
	dest: ${7:/etc/security/limits.conf}
	use_min: ${8:yes|#no}
	backup: ${9:yes|#no}

endsnippet

snippet sysctl "Manage entries in sysctl.conf." b
sysctl:
	name: ${1:# The dot-separated path (aka I(key)) specifying the sysctl variable.}

	reload: ${2:#yes|no}
	state: ${3:#present|absent}
	sysctl_set: ${4:yes|no}
	ignoreerrors: ${5:yes|no}
	sysctl_file: ${6:/etc/sysctl.conf}
	value: ${7:# Desired value of the sysctl key.}

endsnippet

snippet cronvar "Manage variables in crontabs" b
cronvar:
	name: ${1:# Name of the crontab variable.}

	insertbefore: ${2:# Used with C(state=present). If specified, the variable will be inserted just before the variable specified.}
	cron_file: ${3:# If specified, uses this file instead of an individual user's crontab. Without a leading /, this is assumed to be in /etc/cron.d.  With a leading /, this is taken as absolute.}
	value: ${4:# The value to set this variable to.  Required if state=present.}
	state: ${5:#present|absent}
	user: ${6:root}
	insertafter: ${7:# Used with C(state=present). If specified, the variable will be inserted after the variable specified.}
	backup: ${8:no}

endsnippet

snippet command "Executes a command on a remote node" b
command:
	${1:free_form: # the command module takes a free form command to run.  There is no parameter actually named 'free form'. See the examples!}

	warn: ${2:yes}
	creates: ${3:# a filename or (since 2.0) glob pattern, when it already exists, this step will B(not) be run.}
	executable: ${4:# change the shell used to execute the command. Should be an absolute path to the executable.}
	chdir: ${5:# cd into this directory before running the command}
	removes: ${6:# a filename or (since 2.0) glob pattern, when it does not exist, this step will B(not) be run.}

endsnippet

snippet shell "Execute commands in nodes." b
shell:
	${1:free_form: # The shell module takes a free form command to run, as a string.  There's not an actual option named "free form".  See the examples!}

	warn: ${2:yes}
	creates: ${3:# a filename, when it already exists, this step will B(not) be run.}
	executable: ${4:# change the shell used to execute the command. Should be an absolute path to the executable.}
	chdir: ${5:# cd into this directory before running the command}
	removes: ${6:# a filename, when it does not exist, this step will B(not) be run.}

endsnippet

snippet git "Deploy software (or files) from git checkouts" b
git:
	dest: ${1:# Absolute path of where the repository should be checked out to. This parameter is required, unless C(clone) is set to C(no) This change was made in version 1.8.3. Prior to this version, the C(dest) parameter was always required.}
	repo: ${2:# git, SSH, or HTTP(S) protocol address of the git repository.}

	force: ${3:yes|#no}
	track_submodules: ${4:yes|#no}
	reference: ${5:# Reference repository (see "git clone --reference ...")}
	accept_hostkey: ${6:yes|#no}
	clone: ${7:#yes|no}
	update: ${8:#yes|no}
	ssh_opts: ${9:# Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be "-o StrictHostKeyChecking=no"}
	bare: ${10:yes|#no}
	verify_commit: ${11:yes|#no}
	recursive: ${12:#yes|no}
	executable: ${13:# Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used.}
	remote: ${14:origin}
	refspec: ${15:# Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be "refs/meta/config".}
	umask: ${16:# The umask to set before doing any checkouts, or any other repository maintenance.}
	depth: ${17:# Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly.}
	version: ${18:HEAD}
	key_file: ${19:# Specify an optional private key file to use for the checkout.}

endsnippet

snippet find "return a list of files based on specific criteria" b
find:
	paths: ${1:# List of paths of directories to search. All paths must be fully qualified.}

	file_type: ${2:#file|directory|link|any}
	age: ${3:# Select files whose age is equal to or greater than the specified time. Use a negative age to find files equal to or less than the specified time. You can choose seconds, minutes, hours, days, or weeks by specifying the first letter of any of those words (e.g., "1w").}
	contains: ${4:# One or more regex patterns which should be matched against the file content}
	recurse: ${5:yes|#no}
	age_stamp: ${6:atime|#mtime|ctime}
	patterns: ${7:*}
	get_checksum: ${8:True|False}
	use_regex: ${9:True|False}
	follow: ${10:True|False}
	hidden: ${11:True|False}
	size: ${12:# Select files whose size is equal to or greater than the specified size. Use a negative size to find files equal to or less than the specified size. Unqualified values are in bytes, but b, k, m, g, and t can be appended to specify bytes, kilobytes, megabytes, gigabytes, and terabytes, respectively. Size is not evaluated for directories.}

endsnippet

snippet blockinfile "Insert/update/remove a text block surrounded by marker lines." b
blockinfile:
	path: ${1:# The file to modify.}

	group: ${2:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	insertbefore: ${3:BOF|*regex*}
	unsafe_writes: ${4:no}
	selevel: ${5:s0}
	create: ${6:yes|#no}
	seuser: ${7:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	serole: ${8:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	owner: ${9:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	marker: ${10:# {mark} ANSIBLE MANAGED BLOCK}
	state: ${11:#present|absent}
	mode: ${12:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	insertafter: ${13:#EOF|*regex*}
	follow: ${14:yes|#no}
	validate: ${15:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
	attributes: ${16:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	backup: ${17:yes|#no}
	block: ${18:}
	setype: ${19:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}

endsnippet

snippet archive "Creates a compressed archive of one or more files or trees." b
archive:
	path: ${1:# Remote absolute path, glob, or list of paths or globs for the file or files to compress or archive.}

	group: ${2:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	format: ${3:#gz|bz2|zip}
	dest: ${4:# The file name of the destination archive. This is required when C(path) refers to multiple files by either specifying a glob, a directory or multiple paths in a list.}
	selevel: ${5:s0}
	seuser: ${6:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	setype: ${7:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
	remove: ${8:no}
	unsafe_writes: ${9:no}
	serole: ${10:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	mode: ${11:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	attributes: ${12:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	owner: ${13:# Name of the user that should own the file/directory, as would be fed to I(chown).}

endsnippet

snippet file "Sets attributes of files" b
file:
	path: ${1:[]}

	src: ${2:# path of the file to link to (applies only to C(state=link)). Will accept absolute, relative and nonexisting paths. Relative paths are not expanded.}
	force: ${3:yes|#no}
	unsafe_writes: ${4:no}
	selevel: ${5:s0}
	seuser: ${6:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	recurse: ${7:yes|#no}
	serole: ${8:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	group: ${9:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	state: ${10:#file|link|directory|hard|touch|absent}
	mode: ${11:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	follow: ${12:yes|#no}
	owner: ${13:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	attributes: ${14:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	setype: ${15:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}

endsnippet

snippet copy "Copies files to remote locations." b
- name: ${1}
	copy:
		dest: ${2:# Remote absolute path where the file should be copied to. If src is a directory, this must be a directory too.}
		src: ${3:# Local path to a file to copy to the remote server; can be absolute or relative. If path is a directory, it is copied recursively. In this case, if path ends with "/", only inside contents of that directory are copied to destination. Otherwise, if it does not end with "/", the directory itself with all contents is copied. This behavior is similar to Rsync.}
		directory_mode: ${4:# When doing a recursive copy set the mode for the directories. If this is not set we will use the system defaults. The mode is only set on directories which are newly created, and will not affect those that already existed.}
		force: ${5:#yes|no}
		remote_src: ${6:True|#False}
		group: ${7:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		content: ${8:# When used instead of 'src', sets the contents of a file directly to the specified value. This is for simple values, for anything complex or with formatting please switch to the template module.}
		mode: ${9:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
		owner: ${10:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		validate: ${11:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		backup: ${12:yes|#no}
endsnippet

snippet synchronize "A wrapper around rsync to make common tasks in your playbooks quick and easy." b
synchronize:
	src: ${1:# Path on the source host that will be synchronized to the destination; The path can be absolute or relative.}
	dest: ${2:# Path on the destination host that will be synchronized from the source; The path can be absolute or relative.}

	dirs: ${3:yes|#no}
	partial: ${4:no}
	links: ${5:yes|no}
	copy_links: ${6:yes|#no}
	perms: ${7:yes|no}
	compress: ${8:#yes|no}
	rsync_timeout: ${9:0}
	rsync_opts: ${10:# Specify additional rsync options by passing in an array.}
	owner: ${11:yes|no}
	set_remote_user: ${12:yes}
	times: ${13:yes|no}
	rsync_path: ${14:# Specify the rsync command to run on the remote host. See C(--rsync-path) on the rsync man page.}
	dest_port: ${15:Value of ansible_ssh_port for this host, remote_port config setting, or the value from ssh client configuration if none of those are set}
	group: ${16:yes|no}
	existing_only: ${17:yes|#no}
	recursive: ${18:yes|no}
	archive: ${19:#yes|no}
	mode: ${20:#push|pull}
	checksum: ${21:yes|#no}
	verify_host: ${22:no}
	use_ssh_args: ${23:yes|#no}
	delete: ${24:yes|#no}

endsnippet

snippet stat "retrieve file or file system status" b
stat:
	path: ${1:# The full path of the file/object to get the facts of}

	get_checksum: ${2:yes}
	follow: ${3:no}
	checksum_algorithm: ${4:#sha1|sha224|sha256|sha384|sha512}
	get_mime: ${5:#True|False}
	get_md5: ${6:yes}
	get_attributes: ${7:yes}

endsnippet

snippet template "Templates a file out to a remote server." b
template:
	src: ${1:# Path of a Jinja2 formatted template on the Ansible controller. This can be a relative or absolute path.}
	dest: ${2:# Location to render the template to on the remote machine.}

	force: ${3:#yes|no}
	selevel: ${4:s0}
	seuser: ${5:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	setype: ${6:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
	unsafe_writes: ${7:no}
	serole: ${8:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	mode: ${9:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	attributes: ${10:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	owner: ${11:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	group: ${12:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	validate: ${13:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
	backup: ${14:yes|#no}

endsnippet

snippet unarchive "Unpacks an archive after (optionally) copying it from the local machine." b
unarchive:
	src: ${1:# If remote_src=no (default), local path to archive file to copy to the target server; can be absolute or relative. If remote_src=yes, path on the target server to existing archive file to unpack.}
	dest: ${2:# Remote absolute path where the archive should be unpacked}

	seuser: ${3:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	group: ${4:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	remote_src: ${5:yes|#no}
	selevel: ${6:s0}
	list_files: ${7:yes|#no}
	keep_newer: ${8:no}
	setype: ${9:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
	creates: ${10:# a filename, when it already exists, this step will B(not) be run.}
	unsafe_writes: ${11:no}
	serole: ${12:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	mode: ${13:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	exclude: ${14:[]}
	owner: ${15:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	extra_opts: ${16:# Specify additional options by passing in an array.}
	copy: ${17:#yes|no}
	validate_certs: ${18:#yes|no}
	attributes: ${19:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}

endsnippet

snippet lineinfile "Ensure a particular line is in a file, or replace an existing line using a back-referenced regular expression." b
- name: ${1}
	lineinfile:
		path: ${2:# The file to modify.}
		validate: ${3:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}
		group: ${4:# Name of the group that should own the file/directory, as would be fed to I(chown).}
		insertbefore: ${5:BOF|*regex*}
		owner: ${6:# Name of the user that should own the file/directory, as would be fed to I(chown).}
		state: ${7:#present|absent}
		insertafter: ${8:#EOF|*regex*}
		regexp: ${9:# The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove.  Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html).}
		line: ${10:# Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.}
endsnippet

snippet tempfile "Creates temporary files and directories." b
tempfile:
	path: ${1:# Location where temporary file or directory should be created. If path is not specified default system temporary directory will be used.}
	state: ${2:#file|directory}
	prefix: ${3:ansible.}
	suffix: ${4:}

endsnippet

snippet replace "Replace all instances of a particular string in a file using a back-referenced regular expression." b
replace:
	regexp: ${1:# The regular expression to look for in the contents of the file. Uses Python regular expressions; see U(http://docs.python.org/2/library/re.html). Uses multiline mode, which means C(^) and C($) match the beginning and end respectively of I(each line) of the file.}
	path: ${2:# The file to modify.}

	group: ${3:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	unsafe_writes: ${4:no}
	selevel: ${5:s0}
	seuser: ${6:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	setype: ${7:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}
	replace: ${8:# The string to replace regexp matches. May contain backreferences that will get expanded with the regexp capture groups if the regexp matches. If not set, matches are removed entirely.}
	serole: ${9:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	mode: ${10:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	others: ${11:# All arguments accepted by the M(file) module also work here.}
	owner: ${12:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	follow: ${13:yes|#no}
	attributes: ${14:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	backup: ${15:yes|#no}
	validate: ${16:# The validation command to run before copying into place. The path to the file to validate is passed in via '%s' which must be present as in the example below. The command is passed securely so shell features like expansion and pipes won't work.}

endsnippet

snippet ini_file "Tweak settings in INI files" b
ini_file:
	section: ${1:# Section name in INI file. This is added if C(state=present) automatically when a single value is being set.}
	path: ${2:# Path to the INI-style file; this file is created if required.}

	seuser: ${3:# User part of SELinux file context. Will default to system policy, if applicable. If set to C(_default), it will use the C(user) portion of the policy if available.}
	group: ${4:# Name of the group that should own the file/directory, as would be fed to I(chown).}
	option: ${5:# If set (required for changing a I(value)), this is the name of the option.}
	unsafe_writes: ${6:no}
	selevel: ${7:s0}
	no_extra_spaces: ${8:no}
	serole: ${9:# Role part of SELinux file context, C(_default) feature works as for I(seuser).}
	value: ${10:# The string value to be associated with an I(option). May be omitted when removing an I(option).}
	state: ${11:#present|absent}
	mode: ${12:# Mode the file or directory should be. For those used to I(/usr/bin/chmod) remember that modes are actually octal numbers (like 0644). Leaving off the leading zero will likely have unexpected results. As of version 1.8, the mode may be specified as a symbolic mode (for example, C(u+rwx) or C(u=rw,g=r,o=r)).}
	others: ${13:# All arguments accepted by the M(file) module also work here}
	owner: ${14:# Name of the user that should own the file/directory, as would be fed to I(chown).}
	attributes: ${15:# Attributes the file or directory should have. To get supported flags look at the man page for I(chattr) on the target system. This string should contain the attributes in the same order as the one displayed by I(lsattr).}
	backup: ${16:yes|#no}
	create: ${17:#yes|no}
	setype: ${18:# Type part of SELinux file context, C(_default) feature works as for I(seuser).}

endsnippet

snippet fetch "Fetches a file from remote nodes" b
fetch:
	dest: ${1:# A directory to save the file into. For example, if the I(dest) directory is C(/backup) a I(src) file named C(/etc/profile) on host C(host.example.com), would be saved into C(/backup/host.example.com/etc/profile)}
	src: ${2:# The file on the remote system to fetch. This I(must) be a file, not a directory. Recursive fetching may be supported in a later release.}

	validate_checksum: ${3:#yes|no}
	fail_on_missing: ${4:yes|#no}
	flat: ${5:# Allows you to override the default behavior of appending hostname/path/to/file to the destination.  If dest ends with '/', it will use the basename of the source file, similar to the copy module. Obviously this is only handy if the filenames are unique.}

endsnippet
